; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

	TITLE	F:\Finished_Projects\PROJECT_FILES\WhiteNoise\James Robertson SDL Final\SDL_Game\SDL_Game\Enemy.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?value@?$integral_constant@I$07@std@@2IB	; std::integral_constant<unsigned int,8>::value
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?value@?$integral_constant@I$03@std@@2IB	; std::integral_constant<unsigned int,4>::value
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$integral_constant@I$01@std@@2IB	; std::integral_constant<unsigned int,2>::value
PUBLIC	?value@?$integral_constant@I$00@std@@2IB	; std::integral_constant<unsigned int,1>::value
PUBLIC	?value@?$_Maximum@$S@std@@2IB			; std::_Maximum<>::value
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?value@?$_Maximum@$S@std@@2IB
CONST	SEGMENT
?value@?$_Maximum@$S@std@@2IB DD 00H			; std::_Maximum<>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$00@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$00@std@@2IB DD 01H		; std::integral_constant<unsigned int,1>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$01@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$01@std@@2IB DD 02H		; std::integral_constant<unsigned int,2>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$03@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$03@std@@2IB DD 04H		; std::integral_constant<unsigned int,4>::value
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$07@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$07@std@@2IB DD 08H		; std::integral_constant<unsigned int,8>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
PUBLIC	_hypot
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??0_Container_proxy@std@@QAE@XZ			; std::_Container_proxy::_Container_proxy
PUBLIC	??0_Iterator_base12@std@@QAE@XZ			; std::_Iterator_base12::_Iterator_base12
PUBLIC	??0_Iterator_base12@std@@QAE@ABU01@@Z		; std::_Iterator_base12::_Iterator_base12
PUBLIC	??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z	; std::_Iterator_base12::operator=
PUBLIC	??1_Iterator_base12@std@@QAE@XZ			; std::_Iterator_base12::~_Iterator_base12
PUBLIC	?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt
PUBLIC	?_Clrcont@_Iterator_base12@std@@QAEXXZ		; std::_Iterator_base12::_Clrcont
PUBLIC	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
PUBLIC	?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ	; std::_Iterator_base12::_Getpnext
PUBLIC	?_Orphan_me@_Iterator_base12@std@@QAEXXZ	; std::_Iterator_base12::_Orphan_me
PUBLIC	??0enemy@gam@@QAE@XZ				; gam::enemy::enemy
PUBLIC	?spawnPattern@enemy@gam@@QAEXXZ			; gam::enemy::spawnPattern
PUBLIC	?spawnEnemy@enemy@gam@@QAEXHH@Z			; gam::enemy::spawnEnemy
PUBLIC	?moveEnemyPatterns@enemy@gam@@QAEXXZ		; gam::enemy::moveEnemyPatterns
PUBLIC	?drawEnemy@enemy@gam@@QAEXPAUSDL_Renderer@@PAUSDL_Texture@@@Z ; gam::enemy::drawEnemy
PUBLIC	?checkCollisions@enemy@gam@@QAE_NUSDL_Rect@@@Z	; gam::enemy::checkCollisions
PUBLIC	?restartGame@enemy@gam@@QAEXXZ			; gam::enemy::restartGame
PUBLIC	?checkShipCollisions@enemy@gam@@QAE_NUSDL_Rect@@@Z ; gam::enemy::checkShipCollisions
PUBLIC	?eraseEnemy@enemy@gam@@QAEXXZ			; gam::enemy::eraseEnemy
PUBLIC	??0?$allocator@USDL_Rect@@@std@@QAE@XZ		; std::allocator<SDL_Rect>::allocator<SDL_Rect>
PUBLIC	?deallocate@?$allocator@USDL_Rect@@@std@@QAEXPAUSDL_Rect@@I@Z ; std::allocator<SDL_Rect>::deallocate
PUBLIC	?allocate@?$allocator@USDL_Rect@@@std@@QAEPAUSDL_Rect@@I@Z ; std::allocator<SDL_Rect>::allocate
PUBLIC	?construct@?$allocator@USDL_Rect@@@std@@QAEXPAUSDL_Rect@@ABU3@@Z ; std::allocator<SDL_Rect>::construct
PUBLIC	?max_size@?$allocator@USDL_Rect@@@std@@QBEIXZ	; std::allocator<SDL_Rect>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@USDL_Rect@@@std@@@std@@SAIABV?$allocator@USDL_Rect@@@2@@Z ; std::allocator_traits<std::allocator<SDL_Rect> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<SDL_Rect> >::_Wrap_alloc<std::allocator<SDL_Rect> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@QAEPAUSDL_Rect@@I@Z ; std::_Wrap_alloc<std::allocator<SDL_Rect> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@QAEXPAUSDL_Rect@@I@Z ; std::_Wrap_alloc<std::allocator<SDL_Rect> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<SDL_Rect> >::max_size
PUBLIC	??0?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<SDL_Rect> >::_Vector_val<std::_Simple_types<SDL_Rect> >
PUBLIC	??1?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<SDL_Rect> >::~_Vector_val<std::_Simple_types<SDL_Rect> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@@std@@QAE@ABV?$allocator@USDL_Rect@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<SDL_Rect,std::allocator<SDL_Rect> > >::_Vector_alloc<0,std::_Vec_base_types<SDL_Rect,std::allocator<SDL_Rect> > >
PUBLIC	?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<SDL_Rect,std::allocator<SDL_Rect> > >::_Alloc_proxy
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<SDL_Rect,std::allocator<SDL_Rect> > >::_Getal
PUBLIC	??0?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAE@XZ ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::vector<SDL_Rect,std::allocator<SDL_Rect> >
PUBLIC	?capacity@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QBEIXZ ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::capacity
PUBLIC	?_Unused_capacity@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QBEIXZ ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::_Unused_capacity
PUBLIC	?begin@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@XZ ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::begin
PUBLIC	?_Make_iter@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@@Z ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::_Make_iter
PUBLIC	?size@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QBEIXZ ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::size
PUBLIC	?max_size@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QBEIXZ ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::max_size
PUBLIC	??A?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAEAAUSDL_Rect@@I@Z ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::operator[]
PUBLIC	?push_back@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAEXABUSDL_Rect@@@Z ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::push_back
PUBLIC	?erase@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@@Z ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::erase
PUBLIC	?_Destroy@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IAEXPAUSDL_Rect@@0@Z ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::_Destroy
PUBLIC	?_Grow_to@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IBEII@Z ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::_Grow_to
PUBLIC	?_Inside@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IBE_NPBUSDL_Rect@@@Z ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::_Inside
PUBLIC	?_Reallocate@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IAEXI@Z ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::_Reallocate
PUBLIC	?_Reserve@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IAEXI@Z ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::_Reserve
PUBLIC	?_Xlen@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IBEXXZ ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::_Xlen
PUBLIC	?_Orphan_range@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IBEXPAUSDL_Rect@@0@Z ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::_Orphan_range
PUBLIC	??0?$_Iterator012@Urandom_access_iterator_tag@std@@USDL_Rect@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,SDL_Rect,int,SDL_Rect const *,SDL_Rect const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,SDL_Rect,int,SDL_Rect const *,SDL_Rect const &,std::_Iterator_base12>
PUBLIC	??1?$_Iterator012@Urandom_access_iterator_tag@std@@USDL_Rect@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,SDL_Rect,int,SDL_Rect const *,SDL_Rect const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,SDL_Rect,int,SDL_Rect const *,SDL_Rect const &,std::_Iterator_base12>
PUBLIC	??0?$_Iterator012@Urandom_access_iterator_tag@std@@USDL_Rect@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z ; std::_Iterator012<std::random_access_iterator_tag,SDL_Rect,int,SDL_Rect const *,SDL_Rect const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,SDL_Rect,int,SDL_Rect const *,SDL_Rect const &,std::_Iterator_base12>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@std@@QAE@PAUSDL_Rect@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SDL_Rect> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SDL_Rect> > >
PUBLIC	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SDL_Rect> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SDL_Rect> > >
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SDL_Rect> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SDL_Rect> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@std@@QAE@PAUSDL_Rect@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SDL_Rect> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<SDL_Rect> > >
PUBLIC	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SDL_Rect> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<SDL_Rect> > >
PUBLIC	??$addressof@$$CBUSDL_Rect@@@std@@YAPBUSDL_Rect@@ABU1@@Z ; std::addressof<SDL_Rect const >
PUBLIC	??$construct@USDL_Rect@@AAU1@@?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@QAEXPAUSDL_Rect@@AAU2@@Z ; std::_Wrap_alloc<std::allocator<SDL_Rect> >::construct<SDL_Rect,SDL_Rect &>
PUBLIC	??$construct@USDL_Rect@@ABU1@@?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@QAEXPAUSDL_Rect@@ABU2@@Z ; std::_Wrap_alloc<std::allocator<SDL_Rect> >::construct<SDL_Rect,SDL_Rect const &>
PUBLIC	??$_Move@PAUSDL_Rect@@PAU1@@std@@YAPAUSDL_Rect@@PAU1@00@Z ; std::_Move<SDL_Rect *,SDL_Rect *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@@std@@YAXPAUSDL_Rect@@0AAU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<SDL_Rect> > >
PUBLIC	??$_Umove@PAUSDL_Rect@@@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IAEPAUSDL_Rect@@PAU2@00@Z ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::_Umove<SDL_Rect *>
PUBLIC	??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>
PUBLIC	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate
PUBLIC	??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
PUBLIC	??$_Allocate@USDL_Rect@@@std@@YAPAUSDL_Rect@@IPAU1@@Z ; std::_Allocate<SDL_Rect>
PUBLIC	??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>
PUBLIC	??$forward@AAUSDL_Rect@@@std@@YAAAUSDL_Rect@@AAU1@@Z ; std::forward<SDL_Rect &>
PUBLIC	??$construct@USDL_Rect@@AAU1@@?$allocator_traits@V?$allocator@USDL_Rect@@@std@@@std@@SAXAAV?$allocator@USDL_Rect@@@1@PAUSDL_Rect@@AAU3@@Z ; std::allocator_traits<std::allocator<SDL_Rect> >::construct<SDL_Rect,SDL_Rect &>
PUBLIC	??$forward@ABUSDL_Rect@@@std@@YAABUSDL_Rect@@ABU1@@Z ; std::forward<SDL_Rect const &>
PUBLIC	??$construct@USDL_Rect@@ABU1@@?$allocator_traits@V?$allocator@USDL_Rect@@@std@@@std@@SAXAAV?$allocator@USDL_Rect@@@1@PAUSDL_Rect@@ABU3@@Z ; std::allocator_traits<std::allocator<SDL_Rect> >::construct<SDL_Rect,SDL_Rect const &>
PUBLIC	??$_Ptr_cat@USDL_Rect@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUSDL_Rect@@0@Z ; std::_Ptr_cat<SDL_Rect,SDL_Rect>
PUBLIC	??$_Move@PAUSDL_Rect@@PAU1@@std@@YAPAUSDL_Rect@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<SDL_Rect *,SDL_Rect *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@@std@@YAXPAUSDL_Rect@@0AAU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<SDL_Rect> > >
PUBLIC	??$_Uninitialized_move@PAUSDL_Rect@@PAU1@U?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@@std@@YAPAUSDL_Rect@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@0@@Z ; std::_Uninitialized_move<SDL_Rect *,SDL_Rect *,std::_Wrap_alloc<std::allocator<SDL_Rect> > >
PUBLIC	??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>
PUBLIC	??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
PUBLIC	??$construct@USDL_Rect@@AAU1@@?$allocator@USDL_Rect@@@std@@QAEXPAUSDL_Rect@@AAU2@@Z ; std::allocator<SDL_Rect>::construct<SDL_Rect,SDL_Rect &>
PUBLIC	??$move@AAUSDL_Rect@@@std@@YA$$QAUSDL_Rect@@AAU1@@Z ; std::move<SDL_Rect &>
PUBLIC	??$destroy@USDL_Rect@@@?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@QAEXPAUSDL_Rect@@@Z ; std::_Wrap_alloc<std::allocator<SDL_Rect> >::destroy<SDL_Rect>
PUBLIC	??$_Unchecked@PAUSDL_Rect@@@std@@YAPAUSDL_Rect@@PAU1@@Z ; std::_Unchecked<SDL_Rect *>
PUBLIC	??$_Uninit_move@PAUSDL_Rect@@PAU1@U?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@@std@@YAPAUSDL_Rect@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@0@@Z ; std::_Uninit_move<SDL_Rect *,SDL_Rect *,std::_Wrap_alloc<std::allocator<SDL_Rect> > >
PUBLIC	??$_Rechecked@PAUSDL_Rect@@PAU1@@std@@YAAAPAUSDL_Rect@@AAPAU1@PAU1@@Z ; std::_Rechecked<SDL_Rect *,SDL_Rect *>
PUBLIC	??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>
PUBLIC	??$destroy@USDL_Rect@@@?$allocator_traits@V?$allocator@USDL_Rect@@@std@@@std@@SAXAAV?$allocator@USDL_Rect@@@1@PAUSDL_Rect@@@Z ; std::allocator_traits<std::allocator<SDL_Rect> >::destroy<SDL_Rect>
PUBLIC	??$_Val_type@PAUSDL_Rect@@@std@@YAPAUSDL_Rect@@PAU1@@Z ; std::_Val_type<SDL_Rect *>
PUBLIC	??$_Uninit_move@PAUSDL_Rect@@PAU1@V?$allocator@USDL_Rect@@@std@@U1@@std@@YAPAUSDL_Rect@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<SDL_Rect *,SDL_Rect *,std::allocator<SDL_Rect>,SDL_Rect>
PUBLIC	??$destroy@USDL_Rect@@@?$allocator@USDL_Rect@@@std@@QAEXPAUSDL_Rect@@@Z ; std::allocator<SDL_Rect>::destroy<SDL_Rect>
PUBLIC	??$_Debug_range@PAUSDL_Rect@@@std@@YAXPAUSDL_Rect@@0PB_WI@Z ; std::_Debug_range<SDL_Rect *>
PUBLIC	??$_Debug_pointer@USDL_Rect@@@std@@YAXPAUSDL_Rect@@PB_WI@Z ; std::_Debug_pointer<SDL_Rect>
PUBLIC	??$construct@USDL_Rect@@U1@@?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@QAEXPAUSDL_Rect@@$$QAU2@@Z ; std::_Wrap_alloc<std::allocator<SDL_Rect> >::construct<SDL_Rect,SDL_Rect>
PUBLIC	??$_Iter_cat@PAUSDL_Rect@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUSDL_Rect@@@Z ; std::_Iter_cat<SDL_Rect *>
PUBLIC	??$_Debug_range2@PAUSDL_Rect@@@std@@YAXPAUSDL_Rect@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<SDL_Rect *>
PUBLIC	??$forward@USDL_Rect@@@std@@YA$$QAUSDL_Rect@@AAU1@@Z ; std::forward<SDL_Rect>
PUBLIC	??$construct@USDL_Rect@@U1@@?$allocator_traits@V?$allocator@USDL_Rect@@@std@@@std@@SAXAAV?$allocator@USDL_Rect@@@1@PAUSDL_Rect@@$$QAU3@@Z ; std::allocator_traits<std::allocator<SDL_Rect> >::construct<SDL_Rect,SDL_Rect>
PUBLIC	??$construct@USDL_Rect@@U1@@?$allocator@USDL_Rect@@@std@@QAEXPAUSDL_Rect@@$$QAU2@@Z ; std::allocator<SDL_Rect>::construct<SDL_Rect,SDL_Rect>
PUBLIC	??_C@_1JA@EKKHPHED@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@ ; `string'
PUBLIC	??_C@_1IM@COBDDANL@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; `string'
PUBLIC	??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; `string'
PUBLIC	??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@		; `string'
PUBLIC	??_C@_1KC@FFCHHFHE@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAS?$AAD?$AAL?$AA_?$AAR?$AAe?$AAc?$AAt?$AA?0?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EI@HGIDLLCM@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa@ ; `string'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_C@_1IO@HFHPAKCC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; `string'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	__imp___invalid_parameter:PROC
EXTRN	_SDL_HasIntersection:PROC
EXTRN	_SDL_QueryTexture:PROC
EXTRN	_SDL_RenderCopy:PROC
EXTRN	__imp_??0_Lockit@std@@QAE@H@Z:PROC
EXTRN	__imp_??1_Lockit@std@@QAE@XZ:PROC
EXTRN	__imp__rand:PROC
EXTRN	__imp___hypot:PROC
EXTRN	__imp___CrtDbgReportW:PROC
EXTRN	__imp_?_Debug_message@std@@YAXPB_W0I@Z:PROC
EXTRN	__imp_??0_Container_base12@std@@QAE@XZ:PROC
EXTRN	__imp_??1_Container_base12@std@@QAE@XZ:PROC
EXTRN	__imp_?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ:PROC
EXTRN	__imp_?_Orphan_all@_Container_base12@std@@QAEXXZ:PROC
EXTRN	__imp_?_Xbad_alloc@std@@YAXXZ:PROC
EXTRN	__imp_?_Xlength_error@std@@YAXPBD@Z:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ DB 'i'
	DB	00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd', 00H
	DB	' ', 00H, 'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't'
	DB	00H, 'o', 00H, 'r', 00H, ' ', 00H, 'r', 00H, 'a', 00H, 'n', 00H
	DB	'g', 00H, 'e', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ DB 'i'
	DB	00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd', 00H
	DB	' ', 00H, 'n', 00H, 'u', 00H, 'l', 00H, 'l', 00H, ' ', 00H, 'p'
	DB	00H, 'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1IO@HFHPAKCC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1IO@HFHPAKCC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '2', 00H, '.', 00H, '0', 00H, '\', 00H, 'v'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H
	DB	'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'm', 00H, 'e'
	DB	00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1EI@HGIDLLCM@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa@
CONST	SEGMENT
??_C@_1EI@HGIDLLCM@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa@ DB 'v'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'e', 00H, 'r', 00H, 'a', 00H, 's', 00H, 'e', 00H, ' ', 00H, 'i'
	DB	00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H
	DB	'r', 00H, ' ', 00H, 'o', 00H, 'u', 00H, 't', 00H, 's', 00H, 'i'
	DB	00H, 'd', 00H, 'e', 00H, ' ', 00H, 'r', 00H, 'a', 00H, 'n', 00H
	DB	'g', 00H, 'e', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ DB '"'
	DB	00H, 'o', 00H, 'u', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'f', 00H
	DB	' ', 00H, 'r', 00H, 'a', 00H, 'n', 00H, 'g', 00H, 'e', 00H, '"'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1KC@FFCHHFHE@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAS?$AAD?$AAL?$AA_?$AAR?$AAe?$AAc?$AAt?$AA?0?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1KC@FFCHHFHE@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAS?$AAD?$AAL?$AA_?$AAR?$AAe?$AAc?$AAt?$AA?0?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'v', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 'S', 00H
	DB	'D', 00H, 'L', 00H, '_', 00H, 'R', 00H, 'e', 00H, 'c', 00H, 't'
	DB	00H, ',', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'a'
	DB	00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H
	DB	'o', 00H, 'r', 00H, '<', 00H, 's', 00H, 't', 00H, 'r', 00H, 'u'
	DB	00H, 'c', 00H, 't', 00H, ' ', 00H, 'S', 00H, 'D', 00H, 'L', 00H
	DB	'_', 00H, 'R', 00H, 'e', 00H, 'c', 00H, 't', 00H, '>', 00H, ' '
	DB	00H, '>', 00H, ':', 00H, ':', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, '['
	DB	00H, ']', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ DB '%', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
CONST	SEGMENT
??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ DB '"'
	DB	00H, 'S', 00H, 't', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'a', 00H
	DB	'r', 00H, 'd', 00H, ' ', 00H, 'C', 00H, '+', 00H, '+', 00H, ' '
	DB	00H, 'L', 00H, 'i', 00H, 'b', 00H, 'r', 00H, 'a', 00H, 'r', 00H
	DB	'i', 00H, 'e', 00H, 's', 00H, ' ', 00H, 'O', 00H, 'u', 00H, 't'
	DB	00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 'R', 00H, 'a', 00H
	DB	'n', 00H, 'g', 00H, 'e', 00H, '"', 00H, ' ', 00H, '&', 00H, '&'
	DB	00H, ' ', 00H, '0', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
CONST	SEGMENT
??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ DB 'Stand'
	DB	'ard C++ Libraries Out of Range', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ DB 'v'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	's', 00H, 'u', 00H, 'b', 00H, 's', 00H, 'c', 00H, 'r', 00H, 'i'
	DB	00H, 'p', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'u', 00H, 't', 00H
	DB	' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 'r', 00H, 'a', 00H, 'n'
	DB	00H, 'g', 00H, 'e', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1IM@COBDDANL@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1IM@COBDDANL@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '2', 00H, '.', 00H, '0', 00H, '\', 00H, 'v'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H
	DB	'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'v', 00H, 'e', 00H, 'c'
	DB	00H, 't', 00H, 'o', 00H, 'r', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@ DB 'I'
	DB	00H, 'T', 00H, 'E', 00H, 'R', 00H, 'A', 00H, 'T', 00H, 'O', 00H
	DB	'R', 00H, ' ', 00H, 'L', 00H, 'I', 00H, 'S', 00H, 'T', 00H, ' '
	DB	00H, 'C', 00H, 'O', 00H, 'R', 00H, 'R', 00H, 'U', 00H, 'P', 00H
	DB	'T', 00H, 'E', 00H, 'D', 00H, '!', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1JA@EKKHPHED@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1JA@EKKHPHED@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '2', 00H, '.', 00H, '0', 00H, '\', 00H, 'v'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H
	DB	'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'u', 00H, 't'
	DB	00H, 'i', 00H, 'l', 00H, 'i', 00H, 't', 00H, 'y', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@USDL_Rect@@U1@@?$allocator@USDL_Rect@@@std@@QAEXPAUSDL_Rect@@$$QAU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@USDL_Rect@@U1@@?$allocator@USDL_Rect@@@std@@QAEXPAUSDL_Rect@@$$QAU2@@Z$0
__ehfuncinfo$??$construct@USDL_Rect@@U1@@?$allocator@USDL_Rect@@@std@@QAEXPAUSDL_Rect@@$$QAU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@USDL_Rect@@U1@@?$allocator@USDL_Rect@@@std@@QAEXPAUSDL_Rect@@$$QAU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Uninit_move@PAUSDL_Rect@@PAU1@V?$allocator@USDL_Rect@@@std@@U1@@std@@YAPAUSDL_Rect@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_move@PAUSDL_Rect@@PAU1@V?$allocator@USDL_Rect@@@std@@U1@@std@@YAPAUSDL_Rect@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_move@PAUSDL_Rect@@PAU1@V?$allocator@USDL_Rect@@@std@@U1@@std@@YAPAUSDL_Rect@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_move@PAUSDL_Rect@@PAU1@V?$allocator@USDL_Rect@@@std@@U1@@std@@YAPAUSDL_Rect@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_move@PAUSDL_Rect@@PAU1@V?$allocator@USDL_Rect@@@std@@U1@@std@@YAPAUSDL_Rect@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_move@PAUSDL_Rect@@PAU1@V?$allocator@USDL_Rect@@@std@@U1@@std@@YAPAUSDL_Rect@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_move@PAUSDL_Rect@@PAU1@V?$allocator@USDL_Rect@@@std@@U1@@std@@YAPAUSDL_Rect@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_move@PAUSDL_Rect@@PAU1@V?$allocator@USDL_Rect@@@std@@U1@@std@@YAPAUSDL_Rect@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
__ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@USDL_Rect@@AAU1@@?$allocator@USDL_Rect@@@std@@QAEXPAUSDL_Rect@@AAU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@USDL_Rect@@AAU1@@?$allocator@USDL_Rect@@@std@@QAEXPAUSDL_Rect@@AAU2@@Z$0
__ehfuncinfo$??$construct@USDL_Rect@@AAU1@@?$allocator@USDL_Rect@@@std@@QAEXPAUSDL_Rect@@AAU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@USDL_Rect@@AAU1@@?$allocator@USDL_Rect@@@std@@QAEXPAUSDL_Rect@@AAU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@std@@QAE@PAUSDL_Rect@@PBU_Container_base12@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@std@@QAE@PAUSDL_Rect@@PBU_Container_base12@1@@Z$0
__ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@std@@QAE@PAUSDL_Rect@@PBU_Container_base12@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@std@@QAE@PAUSDL_Rect@@PBU_Container_base12@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Orphan_range@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IBEXPAUSDL_Rect@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Orphan_range@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IBEXPAUSDL_Rect@@0@Z$0
__ehfuncinfo$?_Orphan_range@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IBEXPAUSDL_Rect@@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Orphan_range@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IBEXPAUSDL_Rect@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Reallocate@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IAEXI@Z$0
__unwindtable$?_Reallocate@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IAEXI@Z$2
__ehfuncinfo$?_Reallocate@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?erase@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@@Z$0
__ehfuncinfo$?erase@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?erase@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Make_iter@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Make_iter@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@@Z$0
__ehfuncinfo$?_Make_iter@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Make_iter@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@@std@@QAE@ABV?$allocator@USDL_Rect@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@@std@@QAE@ABV?$allocator@USDL_Rect@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@@std@@QAE@ABV?$allocator@USDL_Rect@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@@std@@QAE@ABV?$allocator@USDL_Rect@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?eraseEnemy@enemy@gam@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?eraseEnemy@enemy@gam@@QAEXXZ$0
__ehfuncinfo$?eraseEnemy@enemy@gam@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?eraseEnemy@enemy@gam@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1
__ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0
__ehfuncinfo$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@USDL_Rect@@U1@@?$allocator@USDL_Rect@@@std@@QAEXPAUSDL_Rect@@$$QAU2@@Z
_TEXT	SEGMENT
tv74 = -244						; size = 4
$T2 = -236						; size = 4
$T3 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@USDL_Rect@@U1@@?$allocator@USDL_Rect@@@std@@QAEXPAUSDL_Rect@@$$QAU2@@Z PROC ; std::allocator<SDL_Rect>::construct<SDL_Rect,SDL_Rect>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@USDL_Rect@@U1@@?$allocator@USDL_Rect@@@std@@QAEXPAUSDL_Rect@@$$QAU2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	16					; 00000010H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@USDL_Rect@@@std@@YA$$QAUSDL_Rect@@AAU1@@Z ; std::forward<SDL_Rect>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv74[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv74[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv74[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 601  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@USDL_Rect@@U1@@?$allocator@USDL_Rect@@@std@@QAEXPAUSDL_Rect@@$$QAU2@@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@USDL_Rect@@U1@@?$allocator@USDL_Rect@@@std@@QAEXPAUSDL_Rect@@$$QAU2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-248]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@USDL_Rect@@U1@@?$allocator@USDL_Rect@@@std@@QAEXPAUSDL_Rect@@$$QAU2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@USDL_Rect@@U1@@?$allocator@USDL_Rect@@@std@@QAEXPAUSDL_Rect@@$$QAU2@@Z ENDP ; std::allocator<SDL_Rect>::construct<SDL_Rect,SDL_Rect>
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@USDL_Rect@@U1@@?$allocator_traits@V?$allocator@USDL_Rect@@@std@@@std@@SAXAAV?$allocator@USDL_Rect@@@1@PAUSDL_Rect@@$$QAU3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@USDL_Rect@@U1@@?$allocator_traits@V?$allocator@USDL_Rect@@@std@@@std@@SAXAAV?$allocator@USDL_Rect@@@1@PAUSDL_Rect@@$$QAU3@@Z PROC ; std::allocator_traits<std::allocator<SDL_Rect> >::construct<SDL_Rect,SDL_Rect>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@USDL_Rect@@@std@@YA$$QAUSDL_Rect@@AAU1@@Z ; std::forward<SDL_Rect>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@USDL_Rect@@U1@@?$allocator@USDL_Rect@@@std@@QAEXPAUSDL_Rect@@$$QAU2@@Z ; std::allocator<SDL_Rect>::construct<SDL_Rect,SDL_Rect>

; 724  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$construct@USDL_Rect@@U1@@?$allocator_traits@V?$allocator@USDL_Rect@@@std@@@std@@SAXAAV?$allocator@USDL_Rect@@@1@PAUSDL_Rect@@$$QAU3@@Z ENDP ; std::allocator_traits<std::allocator<SDL_Rect> >::construct<SDL_Rect,SDL_Rect>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@USDL_Rect@@@std@@YA$$QAUSDL_Rect@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@USDL_Rect@@@std@@YA$$QAUSDL_Rect@@AAU1@@Z PROC ; std::forward<SDL_Rect>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$forward@USDL_Rect@@@std@@YA$$QAUSDL_Rect@@AAU1@@Z ENDP ; std::forward<SDL_Rect>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Debug_range2@PAUSDL_Rect@@@std@@YAXPAUSDL_Rect@@0PB_WIUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__File$ = 16						; size = 4
__Line$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Debug_range2@PAUSDL_Rect@@@std@@YAXPAUSDL_Rect@@0PB_WIUrandom_access_iterator_tag@0@@Z PROC ; std::_Debug_range2<SDL_Rect *>, COMDAT

; 570  : 	{	// test iterator pair for valid range, random-access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 571  : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN3@Debug_rang

; 572  : 		{	// check for non-null pointers, valid range
; 573  : 		_DEBUG_POINTER2(_First, _File, _Line);

	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Debug_pointer@USDL_Rect@@@std@@YAXPAUSDL_Rect@@PB_WI@Z ; std::_Debug_pointer<SDL_Rect>
	add	esp, 12					; 0000000cH

; 574  : 		_DEBUG_POINTER2(_Last, _File, _Line);

	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??$_Debug_pointer@USDL_Rect@@@std@@YAXPAUSDL_Rect@@PB_WI@Z ; std::_Debug_pointer<SDL_Rect>
	add	esp, 12					; 0000000cH

; 575  : 		if (_Last < _First)

	mov	eax, DWORD PTR __Last$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	jae	SHORT $LN3@Debug_rang

; 576  : 			_DEBUG_ERROR2("invalid iterator range", _File, _Line);

	mov	esi, esp
	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	push	OFFSET ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@Debug_rang:

; 577  : 		}
; 578  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Debug_range2@PAUSDL_Rect@@@std@@YAXPAUSDL_Rect@@0PB_WIUrandom_access_iterator_tag@0@@Z ENDP ; std::_Debug_range2<SDL_Rect *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Iter_cat@PAUSDL_Rect@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUSDL_Rect@@@Z
_TEXT	SEGMENT
__Cat$ = -5						; size = 1
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAUSDL_Rect@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUSDL_Rect@@@Z PROC ; std::_Iter_cat<SDL_Rect *>, COMDAT

; 405  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 406  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 407  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	cl, BYTE PTR __Cat$[ebp]
	mov	BYTE PTR [eax], cl
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 408  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Iter_cat
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Iter_cat:
	DD	1
	DD	$LN4@Iter_cat
$LN4@Iter_cat:
	DD	-5					; fffffffbH
	DD	1
	DD	$LN3@Iter_cat
$LN3@Iter_cat:
	DB	95					; 0000005fH
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	0
??$_Iter_cat@PAUSDL_Rect@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUSDL_Rect@@@Z ENDP ; std::_Iter_cat<SDL_Rect *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@USDL_Rect@@U1@@?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@QAEXPAUSDL_Rect@@$$QAU2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@USDL_Rect@@U1@@?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@QAEXPAUSDL_Rect@@$$QAU2@@Z PROC ; std::_Wrap_alloc<std::allocator<SDL_Rect> >::construct<SDL_Rect,SDL_Rect>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@USDL_Rect@@@std@@YA$$QAUSDL_Rect@@AAU1@@Z ; std::forward<SDL_Rect>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@USDL_Rect@@U1@@?$allocator_traits@V?$allocator@USDL_Rect@@@std@@@std@@SAXAAV?$allocator@USDL_Rect@@@1@PAUSDL_Rect@@$$QAU3@@Z ; std::allocator_traits<std::allocator<SDL_Rect> >::construct<SDL_Rect,SDL_Rect>
	add	esp, 12					; 0000000cH

; 873  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@USDL_Rect@@U1@@?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@QAEXPAUSDL_Rect@@$$QAU2@@Z ENDP ; std::_Wrap_alloc<std::allocator<SDL_Rect> >::construct<SDL_Rect,SDL_Rect>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Debug_pointer@USDL_Rect@@@std@@YAXPAUSDL_Rect@@PB_WI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__File$ = 12						; size = 4
__Line$ = 16						; size = 4
??$_Debug_pointer@USDL_Rect@@@std@@YAXPAUSDL_Rect@@PB_WI@Z PROC ; std::_Debug_pointer<SDL_Rect>, COMDAT

; 552  : 	{	// test iterator for non-singularity, pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 553  : 	if (_First == 0)

	cmp	DWORD PTR __First$[ebp], 0
	jne	SHORT $LN2@Debug_poin

; 554  : 		_DEBUG_ERROR2("invalid null pointer", _File, _Line);

	mov	esi, esp
	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	push	OFFSET ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Debug_poin:

; 555  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Debug_pointer@USDL_Rect@@@std@@YAXPAUSDL_Rect@@PB_WI@Z ENDP ; std::_Debug_pointer<SDL_Rect>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Debug_range@PAUSDL_Rect@@@std@@YAXPAUSDL_Rect@@0PB_WI@Z
_TEXT	SEGMENT
$T1 = -197						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__File$ = 16						; size = 4
__Line$ = 20						; size = 4
??$_Debug_range@PAUSDL_Rect@@@std@@YAXPAUSDL_Rect@@0PB_WI@Z PROC ; std::_Debug_range<SDL_Rect *>, COMDAT

; 583  : 	{	// test iterator pair for valid range

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 584  : 	_Debug_range2(_First, _Last, _File, _Line, _Iter_cat(_First));

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??$_Iter_cat@PAUSDL_Rect@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUSDL_Rect@@@Z ; std::_Iter_cat<SDL_Rect *>
	add	esp, 8
	mov	dl, BYTE PTR [eax]
	movzx	eax, dl
	push	eax
	mov	ecx, DWORD PTR __Line$[ebp]
	push	ecx
	mov	edx, DWORD PTR __File$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Debug_range2@PAUSDL_Rect@@@std@@YAXPAUSDL_Rect@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<SDL_Rect *>
	add	esp, 20					; 00000014H

; 585  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Debug_range@PAUSDL_Rect@@@std@@YAXPAUSDL_Rect@@0PB_WI@Z ENDP ; std::_Debug_range<SDL_Rect *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@USDL_Rect@@@?$allocator@USDL_Rect@@@std@@QAEXPAUSDL_Rect@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@USDL_Rect@@@?$allocator@USDL_Rect@@@std@@QAEXPAUSDL_Rect@@@Z PROC ; std::allocator<SDL_Rect>::destroy<SDL_Rect>, COMDAT
; _this$ = ecx

; 605  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@USDL_Rect@@@?$allocator@USDL_Rect@@@std@@QAEXPAUSDL_Rect@@@Z ENDP ; std::allocator<SDL_Rect>::destroy<SDL_Rect>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAUSDL_Rect@@PAU1@V?$allocator@USDL_Rect@@@std@@U1@@std@@YAPAUSDL_Rect@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUSDL_Rect@@PAU1@V?$allocator@USDL_Rect@@@std@@U1@@std@@YAPAUSDL_Rect@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<SDL_Rect *,SDL_Rect *,std::allocator<SDL_Rect>,SDL_Rect>, COMDAT

; 437  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_move@PAUSDL_Rect@@PAU1@V?$allocator@USDL_Rect@@@std@@U1@@std@@YAPAUSDL_Rect@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 438  : 	_DEBUG_RANGE(_First, _Last);

	push	438					; 000001b6H
	push	OFFSET ??_C@_1IO@HFHPAKCC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Debug_range@PAUSDL_Rect@@@std@@YAXPAUSDL_Rect@@0PB_WI@Z ; std::_Debug_range<SDL_Rect *>
	add	esp, 16					; 00000010H

; 439  : 	_DEBUG_POINTER(_Dest);

	push	439					; 000001b7H
	push	OFFSET ??_C@_1IO@HFHPAKCC@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	??$_Debug_pointer@USDL_Rect@@@std@@YAXPAUSDL_Rect@@PB_WI@Z ; std::_Debug_pointer<SDL_Rect>
	add	esp, 12					; 0000000cH

; 440  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 441  : 
; 442  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 443  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_mov
$LN5@Uninit_mov:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __First$[ebp], ecx
$LN6@Uninit_mov:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_mov

; 444  : 		_Al.construct(_Dest, (_Valty&&)*_First);

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@USDL_Rect@@U1@@?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@QAEXPAUSDL_Rect@@$$QAU2@@Z ; std::_Wrap_alloc<std::allocator<SDL_Rect> >::construct<SDL_Rect,SDL_Rect>
	jmp	SHORT $LN5@Uninit_mov
$LN4@Uninit_mov:
	jmp	SHORT $LN10@Uninit_mov
__catch$??$_Uninit_move@PAUSDL_Rect@@PAU1@V?$allocator@USDL_Rect@@@std@@U1@@std@@YAPAUSDL_Rect@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 445  : 	_CATCH_ALL
; 446  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_mov
$LN2@Uninit_mov:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_mov:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_mov

; 447  : 		_Al.destroy(_Next);

	mov	eax, DWORD PTR __Next$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@USDL_Rect@@@?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@QAEXPAUSDL_Rect@@@Z ; std::_Wrap_alloc<std::allocator<SDL_Rect> >::destroy<SDL_Rect>
	jmp	SHORT $LN2@Uninit_mov
$LN1@Uninit_mov:

; 448  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 449  : 	_CATCH_END

	mov	eax, $LN13@Uninit_mov
	ret	0
$LN10@Uninit_mov:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$??$_Uninit_move@PAUSDL_Rect@@PAU1@V?$allocator@USDL_Rect@@@std@@U1@@std@@YAPAUSDL_Rect@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1
$LN13@Uninit_mov:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_move@PAUSDL_Rect@@PAU1@V?$allocator@USDL_Rect@@@std@@U1@@std@@YAPAUSDL_Rect@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$1:

; 450  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_mov:

; 451  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_move@PAUSDL_Rect@@PAU1@V?$allocator@USDL_Rect@@@std@@U1@@std@@YAPAUSDL_Rect@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-224]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_move@PAUSDL_Rect@@PAU1@V?$allocator@USDL_Rect@@@std@@U1@@std@@YAPAUSDL_Rect@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_move@PAUSDL_Rect@@PAU1@V?$allocator@USDL_Rect@@@std@@U1@@std@@YAPAUSDL_Rect@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<SDL_Rect *,SDL_Rect *,std::allocator<SDL_Rect>,SDL_Rect>
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAUSDL_Rect@@@std@@YAPAUSDL_Rect@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUSDL_Rect@@@std@@YAPAUSDL_Rect@@PAU1@@Z PROC ; std::_Val_type<SDL_Rect *>, COMDAT

; 645  : 	{	// return value type from arbitrary argument

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 646  : 	return (0);

	xor	eax, eax

; 647  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Val_type@PAUSDL_Rect@@@std@@YAPAUSDL_Rect@@PAU1@@Z ENDP ; std::_Val_type<SDL_Rect *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@USDL_Rect@@@?$allocator_traits@V?$allocator@USDL_Rect@@@std@@@std@@SAXAAV?$allocator@USDL_Rect@@@1@PAUSDL_Rect@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@USDL_Rect@@@?$allocator_traits@V?$allocator@USDL_Rect@@@std@@@std@@SAXAAV?$allocator@USDL_Rect@@@1@PAUSDL_Rect@@@Z PROC ; std::allocator_traits<std::allocator<SDL_Rect> >::destroy<SDL_Rect>, COMDAT

; 728  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@USDL_Rect@@@?$allocator@USDL_Rect@@@std@@QAEXPAUSDL_Rect@@@Z ; std::allocator<SDL_Rect>::destroy<SDL_Rect>

; 731  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$destroy@USDL_Rect@@@?$allocator_traits@V?$allocator@USDL_Rect@@@std@@@std@@SAXAAV?$allocator@USDL_Rect@@@1@PAUSDL_Rect@@@Z ENDP ; std::allocator_traits<std::allocator<SDL_Rect> >::destroy<SDL_Rect>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
_TEXT	SEGMENT
tv74 = -244						; size = 4
$T2 = -236						; size = 4
$T3 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z PROC ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	8
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv74[ebp], edx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv74[ebp], 0
$LN4@construct:
	mov	eax, DWORD PTR tv74[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 601  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-248]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ENDP ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAUSDL_Rect@@PAU1@@std@@YAAAPAUSDL_Rect@@AAPAU1@PAU1@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAUSDL_Rect@@PAU1@@std@@YAAAPAUSDL_Rect@@AAPAU1@PAU1@@Z PROC ; std::_Rechecked<SDL_Rect *,SDL_Rect *>, COMDAT

; 288  : 	{	// reset checked from unchecked, generic

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 289  : 	_Dest = _Src;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR __Src$[ebp]
	mov	DWORD PTR [eax], ecx

; 290  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 291  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Rechecked@PAUSDL_Rect@@PAU1@@std@@YAAAPAUSDL_Rect@@AAPAU1@PAU1@@Z ENDP ; std::_Rechecked<SDL_Rect *,SDL_Rect *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAUSDL_Rect@@PAU1@U?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@@std@@YAPAUSDL_Rect@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -197						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninit_move@PAUSDL_Rect@@PAU1@U?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@@std@@YAPAUSDL_Rect@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@0@@Z PROC ; std::_Uninit_move<SDL_Rect *,SDL_Rect *,std::_Wrap_alloc<std::allocator<SDL_Rect> > >, COMDAT

; 482  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 483  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@USDL_Rect@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUSDL_Rect@@0@Z ; std::_Ptr_cat<SDL_Rect,SDL_Rect>
	add	esp, 8
	mov	BYTE PTR $T1[ebp], al
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Val_type@PAUSDL_Rect@@@std@@YAPAUSDL_Rect@@PAU1@@Z ; std::_Val_type<SDL_Rect *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninit_move@PAUSDL_Rect@@PAU1@V?$allocator@USDL_Rect@@@std@@U1@@std@@YAPAUSDL_Rect@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<SDL_Rect *,SDL_Rect *,std::allocator<SDL_Rect>,SDL_Rect>
	add	esp, 24					; 00000018H

; 485  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_move@PAUSDL_Rect@@PAU1@U?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@@std@@YAPAUSDL_Rect@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@0@@Z ENDP ; std::_Uninit_move<SDL_Rect *,SDL_Rect *,std::_Wrap_alloc<std::allocator<SDL_Rect> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAUSDL_Rect@@@std@@YAPAUSDL_Rect@@PAU1@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAUSDL_Rect@@@std@@YAPAUSDL_Rect@@PAU1@@Z PROC ; std::_Unchecked<SDL_Rect *>, COMDAT

; 280  : 	{	// construct unchecked from checked, generic

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 281  : 	return (_Src);

	mov	eax, DWORD PTR __Src$[ebp]

; 282  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked@PAUSDL_Rect@@@std@@YAPAUSDL_Rect@@PAU1@@Z ENDP ; std::_Unchecked<SDL_Rect *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@USDL_Rect@@@?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@QAEXPAUSDL_Rect@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@USDL_Rect@@@?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@QAEXPAUSDL_Rect@@@Z PROC ; std::_Wrap_alloc<std::allocator<SDL_Rect> >::destroy<SDL_Rect>, COMDAT
; _this$ = ecx

; 877  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@USDL_Rect@@@?$allocator_traits@V?$allocator@USDL_Rect@@@std@@@std@@SAXAAV?$allocator@USDL_Rect@@@1@PAUSDL_Rect@@@Z ; std::allocator_traits<std::allocator<SDL_Rect> >::destroy<SDL_Rect>
	add	esp, 8

; 880  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@USDL_Rect@@@?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@QAEXPAUSDL_Rect@@@Z ENDP ; std::_Wrap_alloc<std::allocator<SDL_Rect> >::destroy<SDL_Rect>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$move@AAUSDL_Rect@@@std@@YA$$QAUSDL_Rect@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAUSDL_Rect@@@std@@YA$$QAUSDL_Rect@@AAU1@@Z PROC ; std::move<SDL_Rect &>, COMDAT

; 1519 : 	{	// forward _Arg as movable

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$move@AAUSDL_Rect@@@std@@YA$$QAUSDL_Rect@@AAU1@@Z ENDP ; std::move<SDL_Rect &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@USDL_Rect@@AAU1@@?$allocator@USDL_Rect@@@std@@QAEXPAUSDL_Rect@@AAU2@@Z
_TEXT	SEGMENT
tv74 = -244						; size = 4
$T2 = -236						; size = 4
$T3 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@USDL_Rect@@AAU1@@?$allocator@USDL_Rect@@@std@@QAEXPAUSDL_Rect@@AAU2@@Z PROC ; std::allocator<SDL_Rect>::construct<SDL_Rect,SDL_Rect &>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@USDL_Rect@@AAU1@@?$allocator@USDL_Rect@@@std@@QAEXPAUSDL_Rect@@AAU2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	16					; 00000010H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@AAUSDL_Rect@@@std@@YAAAUSDL_Rect@@AAU1@@Z ; std::forward<SDL_Rect &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv74[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv74[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv74[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 601  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@USDL_Rect@@AAU1@@?$allocator@USDL_Rect@@@std@@QAEXPAUSDL_Rect@@AAU2@@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@USDL_Rect@@AAU1@@?$allocator@USDL_Rect@@@std@@QAEXPAUSDL_Rect@@AAU2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-248]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@USDL_Rect@@AAU1@@?$allocator@USDL_Rect@@@std@@QAEXPAUSDL_Rect@@AAU2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@USDL_Rect@@AAU1@@?$allocator@USDL_Rect@@@std@@QAEXPAUSDL_Rect@@AAU2@@Z ENDP ; std::allocator<SDL_Rect>::construct<SDL_Rect,SDL_Rect &>
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>

; 724  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z PROC ; std::forward<std::_Container_proxy>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ENDP ; std::forward<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUSDL_Rect@@PAU1@U?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@@std@@YAPAUSDL_Rect@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUSDL_Rect@@PAU1@U?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@@std@@YAPAUSDL_Rect@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@0@@Z PROC ; std::_Uninitialized_move<SDL_Rect *,SDL_Rect *,std::_Wrap_alloc<std::allocator<SDL_Rect> > >, COMDAT

; 492  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 493  : 	return (_Rechecked(_Dest,
; 494  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 495  : 			_Unchecked(_Dest), _Al)));

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Unchecked@PAUSDL_Rect@@@std@@YAPAUSDL_Rect@@PAU1@@Z ; std::_Unchecked<SDL_Rect *>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??$_Unchecked@PAUSDL_Rect@@@std@@YAPAUSDL_Rect@@PAU1@@Z ; std::_Unchecked<SDL_Rect *>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked@PAUSDL_Rect@@@std@@YAPAUSDL_Rect@@PAU1@@Z ; std::_Unchecked<SDL_Rect *>
	add	esp, 4
	push	eax
	call	??$_Uninit_move@PAUSDL_Rect@@PAU1@U?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@@std@@YAPAUSDL_Rect@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@0@@Z ; std::_Uninit_move<SDL_Rect *,SDL_Rect *,std::_Wrap_alloc<std::allocator<SDL_Rect> > >
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Rechecked@PAUSDL_Rect@@PAU1@@std@@YAAAPAUSDL_Rect@@AAPAU1@PAU1@@Z ; std::_Rechecked<SDL_Rect *,SDL_Rect *>
	add	esp, 8
	mov	eax, DWORD PTR [eax]

; 496  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_move@PAUSDL_Rect@@PAU1@U?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@@std@@YAPAUSDL_Rect@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<SDL_Rect *,SDL_Rect *,std::_Wrap_alloc<std::allocator<SDL_Rect> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@@std@@YAXPAUSDL_Rect@@0AAU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@@std@@YAXPAUSDL_Rect@@0AAU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<SDL_Rect> > >, COMDAT

; 80   : 	{	// destroy [_First, _Last), arbitrary type

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 81   : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Destroy_ra
$LN2@Destroy_ra:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Destroy_ra

; 82   : 		_Al.destroy(_First);

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@USDL_Rect@@@?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@QAEXPAUSDL_Rect@@@Z ; std::_Wrap_alloc<std::allocator<SDL_Rect> >::destroy<SDL_Rect>
	jmp	SHORT $LN2@Destroy_ra
$LN4@Destroy_ra:

; 83   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@@std@@YAXPAUSDL_Rect@@0AAU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<SDL_Rect> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Move@PAUSDL_Rect@@PAU1@@std@@YAPAUSDL_Rect@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAUSDL_Rect@@PAU1@@std@@YAPAUSDL_Rect@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<SDL_Rect *,SDL_Rect *>, COMDAT

; 2418 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2419 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN3@Move
$LN2@Move:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Move:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Move

; 2420 : 		*_Dest = _STD move(*_First);

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$move@AAUSDL_Rect@@@std@@YA$$QAUSDL_Rect@@AAU1@@Z ; std::move<SDL_Rect &>
	add	esp, 4
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	jmp	SHORT $LN2@Move
$LN1@Move:

; 2421 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2422 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move@PAUSDL_Rect@@PAU1@@std@@YAPAUSDL_Rect@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<SDL_Rect *,SDL_Rect *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@USDL_Rect@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUSDL_Rect@@0@Z
_TEXT	SEGMENT
__Cat$ = -5						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@USDL_Rect@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUSDL_Rect@@0@Z PROC ; std::_Ptr_cat<SDL_Rect,SDL_Rect>, COMDAT

; 444  : 	{	// return pointer category from pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 447  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Ptr_cat
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Ptr_cat:
	DD	1
	DD	$LN4@Ptr_cat
$LN4@Ptr_cat:
	DD	-5					; fffffffbH
	DD	1
	DD	$LN3@Ptr_cat
$LN3@Ptr_cat:
	DB	95					; 0000005fH
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	0
??$_Ptr_cat@USDL_Rect@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUSDL_Rect@@0@Z ENDP ; std::_Ptr_cat<SDL_Rect,SDL_Rect>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@USDL_Rect@@ABU1@@?$allocator_traits@V?$allocator@USDL_Rect@@@std@@@std@@SAXAAV?$allocator@USDL_Rect@@@1@PAUSDL_Rect@@ABU3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@USDL_Rect@@ABU1@@?$allocator_traits@V?$allocator@USDL_Rect@@@std@@@std@@SAXAAV?$allocator@USDL_Rect@@@1@PAUSDL_Rect@@ABU3@@Z PROC ; std::allocator_traits<std::allocator<SDL_Rect> >::construct<SDL_Rect,SDL_Rect const &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@ABUSDL_Rect@@@std@@YAABUSDL_Rect@@ABU1@@Z ; std::forward<SDL_Rect const &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@USDL_Rect@@@std@@QAEXPAUSDL_Rect@@ABU3@@Z ; std::allocator<SDL_Rect>::construct

; 724  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$construct@USDL_Rect@@ABU1@@?$allocator_traits@V?$allocator@USDL_Rect@@@std@@@std@@SAXAAV?$allocator@USDL_Rect@@@1@PAUSDL_Rect@@ABU3@@Z ENDP ; std::allocator_traits<std::allocator<SDL_Rect> >::construct<SDL_Rect,SDL_Rect const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@ABUSDL_Rect@@@std@@YAABUSDL_Rect@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUSDL_Rect@@@std@@YAABUSDL_Rect@@ABU1@@Z PROC ; std::forward<SDL_Rect const &>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$forward@ABUSDL_Rect@@@std@@YAABUSDL_Rect@@ABU1@@Z ENDP ; std::forward<SDL_Rect const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@USDL_Rect@@AAU1@@?$allocator_traits@V?$allocator@USDL_Rect@@@std@@@std@@SAXAAV?$allocator@USDL_Rect@@@1@PAUSDL_Rect@@AAU3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@USDL_Rect@@AAU1@@?$allocator_traits@V?$allocator@USDL_Rect@@@std@@@std@@SAXAAV?$allocator@USDL_Rect@@@1@PAUSDL_Rect@@AAU3@@Z PROC ; std::allocator_traits<std::allocator<SDL_Rect> >::construct<SDL_Rect,SDL_Rect &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@AAUSDL_Rect@@@std@@YAAAUSDL_Rect@@AAU1@@Z ; std::forward<SDL_Rect &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@USDL_Rect@@AAU1@@?$allocator@USDL_Rect@@@std@@QAEXPAUSDL_Rect@@AAU2@@Z ; std::allocator<SDL_Rect>::construct<SDL_Rect,SDL_Rect &>

; 724  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$construct@USDL_Rect@@AAU1@@?$allocator_traits@V?$allocator@USDL_Rect@@@std@@@std@@SAXAAV?$allocator@USDL_Rect@@@1@PAUSDL_Rect@@AAU3@@Z ENDP ; std::allocator_traits<std::allocator<SDL_Rect> >::construct<SDL_Rect,SDL_Rect &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AAUSDL_Rect@@@std@@YAAAUSDL_Rect@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUSDL_Rect@@@std@@YAAAUSDL_Rect@@AAU1@@Z PROC ; std::forward<SDL_Rect &>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$forward@AAUSDL_Rect@@@std@@YAAAUSDL_Rect@@AAU1@@Z ENDP ; std::forward<SDL_Rect &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
_TEXT	SEGMENT
__Ptr$ = -8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z PROC ; std::_Allocate<std::_Container_proxy>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], 536870911	; 1fffffffH
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 3
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	mov	esi, esp
	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ENDP ; std::_Allocate<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@USDL_Rect@@@std@@YAPAUSDL_Rect@@IPAU1@@Z
_TEXT	SEGMENT
__Ptr$ = -8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@USDL_Rect@@@std@@YAPAUSDL_Rect@@IPAU1@@Z PROC ; std::_Allocate<SDL_Rect>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], 268435455	; 0fffffffH
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 4
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	mov	esi, esp
	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@USDL_Rect@@@std@@YAPAUSDL_Rect@@IPAU1@@Z ENDP ; std::_Allocate<SDL_Rect>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
	add	esp, 12					; 0000000cH

; 873  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 847  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate

; 848  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> >, COMDAT
; _this$ = ecx

; 801  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>

; 802  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 578  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>
	add	esp, 8

; 579  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ PROC	; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>, COMDAT
; _this$ = ecx

; 552  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ENDP	; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??$_Umove@PAUSDL_Rect@@@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IAEPAUSDL_Rect@@PAU2@00@Z
_TEXT	SEGMENT
__Alval$ = -17						; size = 1
_this$ = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAUSDL_Rect@@@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IAEPAUSDL_Rect@@PAU2@00@Z PROC ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::_Umove<SDL_Rect *>, COMDAT
; _this$ = ecx

; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());

	lea	eax, DWORD PTR __Alval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<SDL_Rect,std::allocator<SDL_Rect> > >::_Getal

; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));

	lea	eax, DWORD PTR __Alval$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Uninitialized_move@PAUSDL_Rect@@PAU1@U?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@@std@@YAPAUSDL_Rect@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@0@@Z ; std::_Uninitialized_move<SDL_Rect *,SDL_Rect *,std::_Wrap_alloc<std::allocator<SDL_Rect> > >
	add	esp, 16					; 00000010H

; 1649 : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Umove
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	2
$LN5@Umove:
	DD	1
	DD	$LN4@Umove
$LN4@Umove:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN3@Umove
$LN3@Umove:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	118					; 00000076H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	0
??$_Umove@PAUSDL_Rect@@@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IAEPAUSDL_Rect@@PAU2@00@Z ENDP ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::_Umove<SDL_Rect *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@@std@@YAXPAUSDL_Rect@@0AAU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -197						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@@std@@YAXPAUSDL_Rect@@0AAU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<SDL_Rect> > >, COMDAT

; 95   : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@USDL_Rect@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUSDL_Rect@@0@Z ; std::_Ptr_cat<SDL_Rect,SDL_Rect>
	add	esp, 8
	mov	BYTE PTR $T1[ebp], al
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@@std@@YAXPAUSDL_Rect@@0AAU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<SDL_Rect> > >
	add	esp, 16					; 00000010H

; 97   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@@std@@YAXPAUSDL_Rect@@0AAU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<SDL_Rect> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Move@PAUSDL_Rect@@PAU1@@std@@YAPAUSDL_Rect@@PAU1@00@Z
_TEXT	SEGMENT
$T1 = -197						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAUSDL_Rect@@PAU1@@std@@YAPAUSDL_Rect@@PAU1@00@Z PROC ; std::_Move<SDL_Rect *,SDL_Rect *>, COMDAT

; 2439 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2440 : 	return (_Move(_First, _Last,
; 2441 : 		_Dest, _Ptr_cat(_First, _Dest)));

	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@USDL_Rect@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUSDL_Rect@@0@Z ; std::_Ptr_cat<SDL_Rect,SDL_Rect>
	add	esp, 8
	mov	BYTE PTR $T1[ebp], al
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Move@PAUSDL_Rect@@PAU1@@std@@YAPAUSDL_Rect@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<SDL_Rect *,SDL_Rect *>
	add	esp, 16					; 00000010H

; 2442 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move@PAUSDL_Rect@@PAU1@@std@@YAPAUSDL_Rect@@PAU1@00@Z ENDP ; std::_Move<SDL_Rect *,SDL_Rect *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@USDL_Rect@@ABU1@@?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@QAEXPAUSDL_Rect@@ABU2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@USDL_Rect@@ABU1@@?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@QAEXPAUSDL_Rect@@ABU2@@Z PROC ; std::_Wrap_alloc<std::allocator<SDL_Rect> >::construct<SDL_Rect,SDL_Rect const &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@ABUSDL_Rect@@@std@@YAABUSDL_Rect@@ABU1@@Z ; std::forward<SDL_Rect const &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@USDL_Rect@@ABU1@@?$allocator_traits@V?$allocator@USDL_Rect@@@std@@@std@@SAXAAV?$allocator@USDL_Rect@@@1@PAUSDL_Rect@@ABU3@@Z ; std::allocator_traits<std::allocator<SDL_Rect> >::construct<SDL_Rect,SDL_Rect const &>
	add	esp, 12					; 0000000cH

; 873  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@USDL_Rect@@ABU1@@?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@QAEXPAUSDL_Rect@@ABU2@@Z ENDP ; std::_Wrap_alloc<std::allocator<SDL_Rect> >::construct<SDL_Rect,SDL_Rect const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@USDL_Rect@@AAU1@@?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@QAEXPAUSDL_Rect@@AAU2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@USDL_Rect@@AAU1@@?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@QAEXPAUSDL_Rect@@AAU2@@Z PROC ; std::_Wrap_alloc<std::allocator<SDL_Rect> >::construct<SDL_Rect,SDL_Rect &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@AAUSDL_Rect@@@std@@YAAAUSDL_Rect@@AAU1@@Z ; std::forward<SDL_Rect &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@USDL_Rect@@AAU1@@?$allocator_traits@V?$allocator@USDL_Rect@@@std@@@std@@SAXAAV?$allocator@USDL_Rect@@@1@PAUSDL_Rect@@AAU3@@Z ; std::allocator_traits<std::allocator<SDL_Rect> >::construct<SDL_Rect,SDL_Rect &>
	add	esp, 12					; 0000000cH

; 873  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@USDL_Rect@@AAU1@@?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@QAEXPAUSDL_Rect@@AAU2@@Z ENDP ; std::_Wrap_alloc<std::allocator<SDL_Rect> >::construct<SDL_Rect,SDL_Rect &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@$$CBUSDL_Rect@@@std@@YAPBUSDL_Rect@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUSDL_Rect@@@std@@YAPBUSDL_Rect@@ABU1@@Z PROC ; std::addressof<SDL_Rect const >, COMDAT

; 92   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 96   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$addressof@$$CBUSDL_Rect@@@std@@YAPBUSDL_Rect@@ABU1@@Z ENDP ; std::addressof<SDL_Rect const >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SDL_Rect> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<SDL_Rect> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SDL_Rect> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<SDL_Rect> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@std@@QAE@PAUSDL_Rect@@PBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@std@@QAE@PAUSDL_Rect@@PBU_Container_base12@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SDL_Rect> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<SDL_Rect> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@std@@QAE@PAUSDL_Rect@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SDL_Rect> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SDL_Rect> > >

; 307  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@std@@QAE@PAUSDL_Rect@@PBU_Container_base12@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SDL_Rect> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<SDL_Rect> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SDL_Rect> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SDL_Rect> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator012@Urandom_access_iterator_tag@std@@USDL_Rect@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SDL_Rect> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SDL_Rect> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SDL_Rect> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SDL_Rect> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Iterator012@Urandom_access_iterator_tag@std@@USDL_Rect@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SDL_Rect> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SDL_Rect> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@std@@QAE@PAUSDL_Rect@@PBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@std@@QAE@PAUSDL_Rect@@PBU_Container_base12@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SDL_Rect> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SDL_Rect> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@std@@QAE@PAUSDL_Rect@@PBU_Container_base12@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator012@Urandom_access_iterator_tag@std@@USDL_Rect@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 48   : 		this->_Adopt(_Pvector);

	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 49   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@std@@QAE@PAUSDL_Rect@@PBU_Container_base12@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Iterator012@Urandom_access_iterator_tag@std@@USDL_Rect@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
__ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@std@@QAE@PAUSDL_Rect@@PBU_Container_base12@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@std@@QAE@PAUSDL_Rect@@PBU_Container_base12@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@std@@QAE@PAUSDL_Rect@@PBU_Container_base12@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SDL_Rect> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<SDL_Rect> > >
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Iterator012@Urandom_access_iterator_tag@std@@USDL_Rect@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Iterator012@Urandom_access_iterator_tag@std@@USDL_Rect@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z PROC ; std::_Iterator012<std::random_access_iterator_tag,SDL_Rect,int,SDL_Rect const *,SDL_Rect const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,SDL_Rect,int,SDL_Rect const *,SDL_Rect const &,std::_Iterator_base12>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base12@std@@QAE@ABU01@@Z	; std::_Iterator_base12::_Iterator_base12
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Iterator012@Urandom_access_iterator_tag@std@@USDL_Rect@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z ENDP ; std::_Iterator012<std::random_access_iterator_tag,SDL_Rect,int,SDL_Rect const *,SDL_Rect const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,SDL_Rect,int,SDL_Rect const *,SDL_Rect const &,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Iterator012@Urandom_access_iterator_tag@std@@USDL_Rect@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Iterator012@Urandom_access_iterator_tag@std@@USDL_Rect@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ PROC ; std::_Iterator012<std::random_access_iterator_tag,SDL_Rect,int,SDL_Rect const *,SDL_Rect const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,SDL_Rect,int,SDL_Rect const *,SDL_Rect const &,std::_Iterator_base12>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iterator_base12@std@@QAE@XZ		; std::_Iterator_base12::~_Iterator_base12
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Iterator012@Urandom_access_iterator_tag@std@@USDL_Rect@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ENDP ; std::_Iterator012<std::random_access_iterator_tag,SDL_Rect,int,SDL_Rect const *,SDL_Rect const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,SDL_Rect,int,SDL_Rect const *,SDL_Rect const &,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Iterator012@Urandom_access_iterator_tag@std@@USDL_Rect@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Iterator012@Urandom_access_iterator_tag@std@@USDL_Rect@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ PROC ; std::_Iterator012<std::random_access_iterator_tag,SDL_Rect,int,SDL_Rect const *,SDL_Rect const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,SDL_Rect,int,SDL_Rect const *,SDL_Rect const &,std::_Iterator_base12>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base12@std@@QAE@XZ		; std::_Iterator_base12::_Iterator_base12
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator012@Urandom_access_iterator_tag@std@@USDL_Rect@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ENDP ; std::_Iterator012<std::random_access_iterator_tag,SDL_Rect,int,SDL_Rect const *,SDL_Rect const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,SDL_Rect,int,SDL_Rect const *,SDL_Rect const &,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IBEXPAUSDL_Rect@@0@Z
_TEXT	SEGMENT
__Pnext$ = -44						; size = 4
__Lock$ = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Orphan_range@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IBEXPAUSDL_Rect@@0@Z PROC ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1764 : 		{	// orphan iterators within specified (inclusive) range

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Orphan_range@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IBEXPAUSDL_Rect@@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1765 : 		_Lockit _Lock(_LOCK_DEBUG);

	mov	esi, esp
	push	3
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1766 : 		const_iterator **_Pnext = (const_iterator **)this->_Getpfirst();

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Pnext$[ebp], eax

; 1767 : 		if (_Pnext != 0)

	cmp	DWORD PTR __Pnext$[ebp], 0
	je	SHORT $LN6@Orphan_ran
$LN5@Orphan_ran:

; 1768 : 			while (*_Pnext != 0)

	mov	eax, DWORD PTR __Pnext$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN6@Orphan_ran

; 1769 : 				if ((*_Pnext)->_Ptr < _First || _Last < (*_Pnext)->_Ptr)

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR __First$[ebp]
	jb	SHORT $LN2@Orphan_ran
	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Last$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jae	SHORT $LN3@Orphan_ran
$LN2@Orphan_ran:

; 1770 : 					_Pnext = (const_iterator **)(*_Pnext)->_Getpnext();

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext
	mov	DWORD PTR __Pnext$[ebp], eax

; 1771 : 				else

	jmp	SHORT $LN1@Orphan_ran
$LN3@Orphan_ran:

; 1772 : 					{	// orphan the iterator
; 1773 : 					(*_Pnext)->_Clrcont();

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?_Clrcont@_Iterator_base12@std@@QAEXXZ	; std::_Iterator_base12::_Clrcont

; 1774 : 					*_Pnext = *(const_iterator **)(*_Pnext)->_Getpnext();

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext
	mov	ecx, DWORD PTR __Pnext$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
$LN1@Orphan_ran:

; 1775 : 					}

	jmp	SHORT $LN5@Orphan_ran
$LN6@Orphan_ran:

; 1776 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN13@Orphan_ran
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN13@Orphan_ran:
	DD	1
	DD	$LN12@Orphan_ran
$LN12@Orphan_ran:
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN10@Orphan_ran
$LN10@Orphan_ran:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Orphan_range@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IBEXPAUSDL_Rect@@0@Z$0:
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	jmp	__RTC_CheckEsp
__ehhandler$?_Orphan_range@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IBEXPAUSDL_Rect@@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-244]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Orphan_range@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IBEXPAUSDL_Rect@@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Orphan_range@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IBEXPAUSDL_Rect@@0@Z ENDP ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::_Orphan_range
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Xlen@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IBEXXZ PROC ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::_Xlen, COMDAT
; _this$ = ecx

; 1753 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1754 : 		_Xlength_error("vector<T> too long");

	mov	esi, esp
	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Xlen:

; 1755 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IBEXXZ ENDP ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IAEXI@Z PROC ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::_Reserve, COMDAT
; _this$ = ecx

; 1612 : 		{	// ensure room for _Count new elements, grow exponentially

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1613 : 		if (_Unused_capacity() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Unused_capacity@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QBEIXZ ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::_Unused_capacity
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN4@Reserve

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QBEIXZ ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QBEIXZ ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN1@Reserve

; 1616 : 				_Xlen();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IBEXXZ ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::_Xlen
$LN1@Reserve:

; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QBEIXZ ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::size
	add	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow_to@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IBEII@Z ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::_Grow_to
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reallocate@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IAEXI@Z ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::_Reallocate
$LN4@Reserve:

; 1618 : 			}
; 1619 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Reserve@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IAEXI@Z ENDP ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
$T2 = -273						; size = 1
$T3 = -261						; size = 1
$T4 = -249						; size = 1
__Size$ = -48						; size = 4
__Ptr$ = -36						; size = 4
_this$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?_Reallocate@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IAEXI@Z PROC ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::_Reallocate, COMDAT
; _this$ = ecx

; 1587 : 		{	// move to array of exactly _Count elements

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Reallocate@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-280]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<SDL_Rect,std::allocator<SDL_Rect> > >::_Getal
	mov	ecx, eax
	call	?allocate@?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@QAEPAUSDL_Rect@@I@Z ; std::_Wrap_alloc<std::allocator<SDL_Rect> >::allocate
	mov	DWORD PTR __Ptr$[ebp], eax

; 1589 : 
; 1590 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUSDL_Rect@@@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IAEPAUSDL_Rect@@PAU2@00@Z ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::_Umove<SDL_Rect *>
	jmp	SHORT $LN5@Reallocate
__catch$?_Reallocate@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IAEXI@Z$0:

; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<SDL_Rect,std::allocator<SDL_Rect> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@QAEXPAUSDL_Rect@@I@Z ; std::_Wrap_alloc<std::allocator<SDL_Rect> >::deallocate

; 1594 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1595 : 		_CATCH_END

	mov	eax, $LN8@Reallocate
	ret	0
$LN5@Reallocate:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Reallocate@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IAEXI@Z$1
$LN8@Reallocate:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Reallocate@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IAEXI@Z$1:

; 1596 : 
; 1597 : 		size_type _Size = size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QBEIXZ ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::size
	mov	DWORD PTR __Size$[ebp], eax

; 1598 : 		if (this->_Myfirst != pointer())

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Reallocate

; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IAEXPAUSDL_Rect@@0@Z ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::_Destroy

; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 4
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<SDL_Rect,std::allocator<SDL_Rect> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@QAEXPAUSDL_Rect@@I@Z ; std::_Wrap_alloc<std::allocator<SDL_Rect> >::deallocate
$LN1@Reallocate:

; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?_Orphan_all@_Container_base12@std@@QAEXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1606 : 		this->_Myend = _Ptr + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR __Ptr$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1607 : 		this->_Mylast = _Ptr + _Size;

	mov	eax, DWORD PTR __Size$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR __Ptr$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1608 : 		this->_Myfirst = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [eax+4], ecx
$LN4@Reallocate:

; 1609 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 280				; 00000118H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IAEXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-284]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Reallocate@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Reallocate@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IAEXI@Z ENDP ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::_Reallocate
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IBE_NPBUSDL_Rect@@@Z
_TEXT	SEGMENT
tv76 = -208						; size = 4
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IBE_NPBUSDL_Rect@@@Z PROC ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::_Inside, COMDAT
; _this$ = ecx

; 1582 : 		{	// test if _Ptr points inside vector

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN3@Inside
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
	mov	DWORD PTR tv76[ebp], 1
	jmp	SHORT $LN4@Inside
$LN3@Inside:
	mov	DWORD PTR tv76[ebp], 0
$LN4@Inside:
	mov	al, BYTE PTR tv76[ebp]

; 1584 : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IBE_NPBUSDL_Rect@@@Z ENDP ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -220						; size = 4
__Capacity$ = -20					; size = 4
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IBEII@Z PROC ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::_Grow_to, COMDAT
; _this$ = ecx

; 1571 : 		{	// grow by 50% or at least to _Count

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1572 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QBEIXZ ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QBEIXZ ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::max_size
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN4@Grow_to
	mov	DWORD PTR tv73[ebp], 0
	jmp	SHORT $LN5@Grow_to
$LN4@Grow_to:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv73[ebp], edx
$LN5@Grow_to:
	mov	eax, DWORD PTR tv73[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1576 : 		if (_Capacity < _Count)

	mov	eax, DWORD PTR __Capacity$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN1@Grow_to

; 1577 : 			_Capacity = _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax
$LN1@Grow_to:

; 1578 : 		return (_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]

; 1579 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Grow_to@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IBEII@Z ENDP ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IAEXPAUSDL_Rect@@0@Z
_TEXT	SEGMENT
__Alval$ = -17						; size = 1
_this$ = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IAEXPAUSDL_Rect@@0@Z PROC ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::_Destroy, COMDAT
; _this$ = ecx

; 1565 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1566 : 		_Alty _Alval(this->_Getal());

	lea	eax, DWORD PTR __Alval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<SDL_Rect,std::allocator<SDL_Rect> > >::_Getal

; 1567 : 		_Destroy_range(_First, _Last, _Alval);

	lea	eax, DWORD PTR __Alval$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@@std@@YAXPAUSDL_Rect@@0AAU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<SDL_Rect> > >
	add	esp, 12					; 0000000cH

; 1568 : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Destroy
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN5@Destroy:
	DD	1
	DD	$LN4@Destroy
$LN4@Destroy:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN3@Destroy
$LN3@Destroy:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	118					; 00000076H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	0
?_Destroy@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IAEXPAUSDL_Rect@@0@Z ENDP ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?erase@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
tv182 = -248						; size = 4
tv181 = -244						; size = 4
$T2 = -236						; size = 4
$T3 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 12
?erase@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@@Z PROC ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::erase, COMDAT
; _this$ = ecx

; 1438 : 		{	// erase element at where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?erase@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 236				; 000000ecH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-248]
	mov	ecx, 59					; 0000003bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T3[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	cmp	eax, DWORD PTR _this$[ebp]
	jne	SHORT $LN1@erase
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp+8]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN1@erase
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR __Where$[ebp+8]
	ja	SHORT $LN2@erase
$LN1@erase:

; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");

	mov	esi, esp
	push	1442					; 000005a2H
	push	OFFSET ??_C@_1IM@COBDDANL@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1EI@HGIDLLCM@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@erase:

; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));

	mov	eax, DWORD PTR __Where$[ebp+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+8]
	add	eax, 16					; 00000010H
	push	eax
	call	??$_Move@PAUSDL_Rect@@PAU1@@std@@YAPAUSDL_Rect@@PAU1@00@Z ; std::_Move<SDL_Rect *,SDL_Rect *>
	add	esp, 12					; 0000000cH

; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, 16					; 00000010H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IAEXPAUSDL_Rect@@0@Z ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::_Destroy

; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IBEXPAUSDL_Rect@@0@Z ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::_Orphan_range

; 1446 : 		--this->_Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1447 : 		return (_Make_iter(_Where));

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T2[ebp], esp
	lea	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv181[ebp], eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@@Z ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::_Make_iter
	mov	DWORD PTR tv182[ebp], eax
	mov	edx, DWORD PTR $T3[ebp]
	or	edx, 1
	mov	DWORD PTR $T3[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1448 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 248				; 000000f8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@@Z$0:
	lea	ecx, DWORD PTR __Where$[ebp]
	jmp	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@std@@QAE@XZ
__ehhandler$?erase@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-252]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?erase@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@@Z ENDP ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::erase
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?push_back@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAEXABUSDL_Rect@@@Z
_TEXT	SEGMENT
$T1 = -233						; size = 1
$T2 = -221						; size = 1
__Idx$3 = -20						; size = 4
_this$ = -8						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAEXABUSDL_Rect@@@Z PROC ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::push_back, COMDAT
; _this$ = ecx

; 1243 : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1244 : 		if (_Inside(_STD addressof(_Val)))

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$addressof@$$CBUSDL_Rect@@@std@@YAPBUSDL_Rect@@ABU1@@Z ; std::addressof<SDL_Rect const >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IBE_NPBUSDL_Rect@@@Z ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	$LN4@push_back

; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$addressof@$$CBUSDL_Rect@@@std@@YAPBUSDL_Rect@@ABU1@@Z ; std::addressof<SDL_Rect const >
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 4
	mov	DWORD PTR __Idx$3[ebp], eax

; 1247 : 			if (this->_Mylast == this->_Myend)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+12]
	jne	SHORT $LN3@push_back

; 1248 : 				_Reserve(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reserve@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IAEXI@Z ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::_Reserve
$LN3@push_back:

; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IBEXPAUSDL_Rect@@0@Z ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::_Orphan_range

; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);

	mov	eax, DWORD PTR __Idx$3[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+4]
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<SDL_Rect,std::allocator<SDL_Rect> > >::_Getal
	mov	ecx, eax
	call	??$construct@USDL_Rect@@AAU1@@?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@QAEXPAUSDL_Rect@@AAU2@@Z ; std::_Wrap_alloc<std::allocator<SDL_Rect> >::construct<SDL_Rect,SDL_Rect &>

; 1252 : 			++this->_Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1253 : 			}
; 1254 : 		else

	jmp	SHORT $LN5@push_back
$LN4@push_back:

; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+12]
	jne	SHORT $LN1@push_back

; 1257 : 				_Reserve(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reserve@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IAEXI@Z ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::_Reserve
$LN1@push_back:

; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@IBEXPAUSDL_Rect@@0@Z ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::_Orphan_range

; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<SDL_Rect,std::allocator<SDL_Rect> > >::_Getal
	mov	ecx, eax
	call	??$construct@USDL_Rect@@ABU1@@?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@QAEXPAUSDL_Rect@@ABU2@@Z ; std::_Wrap_alloc<std::allocator<SDL_Rect> >::construct<SDL_Rect,SDL_Rect const &>

; 1261 : 			++this->_Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN5@push_back:

; 1262 : 			}
; 1263 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAEXABUSDL_Rect@@@Z ENDP ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??A?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAEAAUSDL_Rect@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAEAAUSDL_Rect@@I@Z PROC ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::operator[], COMDAT
; _this$ = ecx

; 1197 : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QBEIXZ ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::size
	cmp	eax, DWORD PTR __Pos$[ebp]
	ja	$LN1@operator

; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");

	mov	esi, esp
	push	1201					; 000004b1H
	push	OFFSET ??_C@_1IM@COBDDANL@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;

	mov	eax, OFFSET ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
	test	eax, eax
	je	SHORT $LN4@operator
	xor	ecx, ecx
	jne	SHORT $LN5@operator
$LN4@operator:
	mov	esi, esp
	push	OFFSET ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
	push	OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
	push	0
	push	1202					; 000004b2H
	push	OFFSET ??_C@_1IM@COBDDANL@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN5@operator
	int	3
$LN5@operator:
	mov	esi, esp
	push	0
	push	1202					; 000004b2H
	push	OFFSET ??_C@_1IM@COBDDANL@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1KC@FFCHHFHE@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAS?$AAD?$AAL?$AA_?$AAR?$AAe?$AAc?$AAt?$AA?0?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@operator:

; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));

	mov	eax, DWORD PTR __Pos$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+4]

; 1210 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAEAAUSDL_Rect@@I@Z ENDP ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?max_size@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
?max_size@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QBEIXZ PROC ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::max_size, COMDAT
; _this$ = ecx

; 1152 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1153 : 		return (this->_Getal().max_size());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<SDL_Rect,std::allocator<SDL_Rect> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<SDL_Rect> >::max_size

; 1154 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QBEIXZ ENDP ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?size@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?size@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QBEIXZ PROC ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::size, COMDAT
; _this$ = ecx

; 1147 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 4

; 1149 : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QBEIXZ ENDP ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
$T2 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 12
?_Make_iter@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@@Z PROC ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::_Make_iter, COMDAT
; _this$ = ecx

; 1044 : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Make_iter@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T2[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1045 : 		return (iterator(_Where._Ptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+8]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@std@@QAE@PAUSDL_Rect@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SDL_Rect> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<SDL_Rect> > >
	mov	edx, DWORD PTR $T2[ebp]
	or	edx, 1
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1046 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Make_iter@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@@Z$0:
	lea	ecx, DWORD PTR __Where$[ebp]
	jmp	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@std@@QAE@XZ
__ehhandler$?_Make_iter@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Make_iter@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Make_iter@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@@Z ENDP ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::_Make_iter
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?begin@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@XZ PROC ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1025 : 		return (iterator(this->_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@std@@QAE@PAUSDL_Rect@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SDL_Rect> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<SDL_Rect> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1026 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@XZ ENDP ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Unused_capacity@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QBEIXZ PROC ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1014 : 		{	// micro-optimization for capacity() - size()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1015 : 		return (this->_Myend - this->_Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+8]
	sar	eax, 4

; 1016 : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Unused_capacity@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QBEIXZ ENDP ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?capacity@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?capacity@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QBEIXZ PROC ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::capacity, COMDAT
; _this$ = ecx

; 1009 : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1010 : 		return (this->_Myend - this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 4

; 1011 : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QBEIXZ ENDP ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
??0?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAE@XZ PROC ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::vector<SDL_Rect,std::allocator<SDL_Rect> >, COMDAT
; _this$ = ecx

; 680  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@USDL_Rect@@@std@@QAE@XZ	; std::allocator<SDL_Rect>::allocator<SDL_Rect>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@@std@@QAE@ABV?$allocator@USDL_Rect@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<SDL_Rect,std::allocator<SDL_Rect> > >::_Vector_alloc<0,std::_Vec_base_types<SDL_Rect,std::allocator<SDL_Rect> > >

; 681  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAE@XZ ENDP ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::vector<SDL_Rect,std::allocator<SDL_Rect> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<SDL_Rect,std::allocator<SDL_Rect> > >::_Getal, COMDAT
; _this$ = ecx

; 641  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<SDL_Rect> >::_Wrap_alloc<std::allocator<SDL_Rect> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 643  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<SDL_Rect,std::allocator<SDL_Rect> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -228						; size = 8
__Alproxy$ = -17					; size = 1
_this$ = -8						; size = 4
?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<SDL_Rect,std::allocator<SDL_Rect> > >::_Alloc_proxy, COMDAT
; _this$ = ecx

; 621  : 		{	// construct proxy from _Alval

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		typename _Alty::template rebind<_Container_proxy>::other
; 623  : 			_Alproxy;

	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> >

; 624  : 		this->_Myproxy = _Alproxy.allocate(1);

	push	1
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 625  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());

	lea	ecx, DWORD PTR $T1[ebp]
	call	??0_Container_proxy@std@@QAE@XZ		; std::_Container_proxy::_Container_proxy
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>

; 626  : 		this->_Myproxy->_Mycont = this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], edx

; 627  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Alloc_prox
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@Alloc_prox:
	DD	1
	DD	$LN4@Alloc_prox
$LN4@Alloc_prox:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN3@Alloc_prox
$LN3@Alloc_prox:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	120					; 00000078H
	DB	121					; 00000079H
	DB	0
?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<SDL_Rect,std::allocator<SDL_Rect> > >::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@@std@@QAE@ABV?$allocator@USDL_Rect@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@@std@@QAE@ABV?$allocator@USDL_Rect@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<SDL_Rect,std::allocator<SDL_Rect> > >::_Vector_alloc<0,std::_Vec_base_types<SDL_Rect,std::allocator<SDL_Rect> > >, COMDAT
; _this$ = ecx

; 601  : 	_Vector_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@@std@@QAE@ABV?$allocator@USDL_Rect@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<SDL_Rect> >::_Vector_val<std::_Simple_types<SDL_Rect> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 602  : 		{	// construct allocator from _Al
; 603  : 		_Alloc_proxy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<SDL_Rect,std::allocator<SDL_Rect> > >::_Alloc_proxy

; 604  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@@std@@QAE@ABV?$allocator@USDL_Rect@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@@std@@QAE@ABV?$allocator@USDL_Rect@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@@std@@QAE@ABV?$allocator@USDL_Rect@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@@std@@QAE@ABV?$allocator@USDL_Rect@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<SDL_Rect,std::allocator<SDL_Rect> > >::_Vector_alloc<0,std::_Vec_base_types<SDL_Rect,std::allocator<SDL_Rect> > >
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<SDL_Rect> >::~_Vector_val<std::_Simple_types<SDL_Rect> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1_Container_base12@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<SDL_Rect> >::~_Vector_val<std::_Simple_types<SDL_Rect> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<SDL_Rect> >::_Vector_val<std::_Simple_types<SDL_Rect> >, COMDAT
; _this$ = ecx

; 480  : 	_Vector_val()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0_Container_base12@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 483  : 		_Mylast = pointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 484  : 		_Myend = pointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 485  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<SDL_Rect> >::_Vector_val<std::_Simple_types<SDL_Rect> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<SDL_Rect> >::max_size, COMDAT
; _this$ = ecx

; 883  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 884  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@USDL_Rect@@@std@@@std@@SAIABV?$allocator@USDL_Rect@@@2@@Z ; std::allocator_traits<std::allocator<SDL_Rect> >::max_size
	add	esp, 4

; 885  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<SDL_Rect> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@QAEXPAUSDL_Rect@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@QAEXPAUSDL_Rect@@I@Z PROC ; std::_Wrap_alloc<std::allocator<SDL_Rect> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 858  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@USDL_Rect@@@std@@QAEXPAUSDL_Rect@@I@Z ; std::allocator<SDL_Rect>::deallocate

; 859  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@QAEXPAUSDL_Rect@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<SDL_Rect> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@QAEPAUSDL_Rect@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@QAEPAUSDL_Rect@@I@Z PROC ; std::_Wrap_alloc<std::allocator<SDL_Rect> >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 847  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@USDL_Rect@@@std@@QAEPAUSDL_Rect@@I@Z ; std::allocator<SDL_Rect>::allocate

; 848  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@QAEPAUSDL_Rect@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<SDL_Rect> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<SDL_Rect> >::_Wrap_alloc<std::allocator<SDL_Rect> >, COMDAT
; _this$ = ecx

; 801  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@USDL_Rect@@@std@@QAE@XZ	; std::allocator<SDL_Rect>::allocator<SDL_Rect>

; 802  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@USDL_Rect@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<SDL_Rect> >::_Wrap_alloc<std::allocator<SDL_Rect> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@USDL_Rect@@@std@@@std@@SAIABV?$allocator@USDL_Rect@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@USDL_Rect@@@std@@@std@@SAIABV?$allocator@USDL_Rect@@@2@@Z PROC ; std::allocator_traits<std::allocator<SDL_Rect> >::max_size, COMDAT

; 734  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 735  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@USDL_Rect@@@std@@QBEIXZ ; std::allocator<SDL_Rect>::max_size

; 736  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@USDL_Rect@@@std@@@std@@SAIABV?$allocator@USDL_Rect@@@2@@Z ENDP ; std::allocator_traits<std::allocator<SDL_Rect> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@USDL_Rect@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?max_size@?$allocator@USDL_Rect@@@std@@QBEIXZ PROC	; std::allocator<SDL_Rect>::max_size, COMDAT
; _this$ = ecx

; 611  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 268435455				; 0fffffffH

; 613  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@USDL_Rect@@@std@@QBEIXZ ENDP	; std::allocator<SDL_Rect>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?construct@?$allocator@USDL_Rect@@@std@@QAEXPAUSDL_Rect@@ABU3@@Z
_TEXT	SEGMENT
tv69 = -220						; size = 4
$T1 = -212						; size = 4
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@USDL_Rect@@@std@@QAEXPAUSDL_Rect@@ABU3@@Z PROC ; std::allocator<SDL_Rect>::construct, COMDAT
; _this$ = ecx

; 592  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 593  : 		::new ((void *)_Ptr) _Ty(_Val);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	16					; 00000010H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR $T1[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	mov	edx, DWORD PTR $T1[ebp]
	mov	DWORD PTR tv69[ebp], edx
	jmp	SHORT $LN1@construct
$LN3@construct:
	mov	DWORD PTR tv69[ebp], 0
$LN1@construct:

; 594  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@USDL_Rect@@@std@@QAEXPAUSDL_Rect@@ABU3@@Z ENDP ; std::allocator<SDL_Rect>::construct
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@USDL_Rect@@@std@@QAEPAUSDL_Rect@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@USDL_Rect@@@std@@QAEPAUSDL_Rect@@I@Z PROC ; std::allocator<SDL_Rect>::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 578  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@USDL_Rect@@@std@@YAPAUSDL_Rect@@IPAU1@@Z ; std::_Allocate<SDL_Rect>
	add	esp, 8

; 579  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@USDL_Rect@@@std@@QAEPAUSDL_Rect@@I@Z ENDP ; std::allocator<SDL_Rect>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@USDL_Rect@@@std@@QAEXPAUSDL_Rect@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@USDL_Rect@@@std@@QAEXPAUSDL_Rect@@I@Z PROC ; std::allocator<SDL_Rect>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 573  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 574  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@USDL_Rect@@@std@@QAEXPAUSDL_Rect@@I@Z ENDP ; std::allocator<SDL_Rect>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@USDL_Rect@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$allocator@USDL_Rect@@@std@@QAE@XZ PROC		; std::allocator<SDL_Rect>::allocator<SDL_Rect>, COMDAT
; _this$ = ecx

; 552  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@USDL_Rect@@@std@@QAE@XZ ENDP		; std::allocator<SDL_Rect>::allocator<SDL_Rect>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File f:\finished_projects\project_files\whitenoise\james robertson sdl final\sdl_game\sdl_game\enemy.cpp
;	COMDAT ?eraseEnemy@enemy@gam@@QAEXXZ
_TEXT	SEGMENT
tv129 = -284						; size = 4
tv128 = -280						; size = 4
tv94 = -276						; size = 4
tv131 = -272						; size = 4
$T2 = -264						; size = 4
$T3 = -252						; size = 12
$T4 = -232						; size = 12
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?eraseEnemy@enemy@gam@@QAEXXZ PROC			; gam::enemy::eraseEnemy, COMDAT
; _this$ = ecx

; 266  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?eraseEnemy@enemy@gam@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 272				; 00000110H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-284]
	mov	ecx, 68					; 00000044H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 267  : 	// Erase the start of the array
; 268  : 	enemies.erase(enemies.begin());

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@XZ ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::begin
	mov	DWORD PTR tv131[ebp], eax
	mov	ecx, DWORD PTR tv131[ebp]
	mov	DWORD PTR tv94[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T2[ebp], esp
	mov	edx, DWORD PTR tv94[ebp]
	push	edx
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv128[ebp], eax
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@2@@Z ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::erase
	mov	DWORD PTR tv129[ebp], eax
	lea	ecx, DWORD PTR $T4[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@std@@QAE@XZ

; 269  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 284				; 0000011cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?eraseEnemy@enemy@gam@@QAEXXZ$0:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USDL_Rect@@@std@@@std@@@std@@QAE@XZ
__ehhandler$?eraseEnemy@enemy@gam@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-288]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?eraseEnemy@enemy@gam@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?eraseEnemy@enemy@gam@@QAEXXZ ENDP			; gam::enemy::eraseEnemy
; Function compile flags: /Odtp /RTCsu /ZI
; File f:\finished_projects\project_files\whitenoise\james robertson sdl final\sdl_game\sdl_game\enemy.cpp
;	COMDAT ?checkShipCollisions@enemy@gam@@QAE_NUSDL_Rect@@@Z
_TEXT	SEGMENT
_i$1 = -20						; size = 4
_this$ = -8						; size = 4
_ship$ = 8						; size = 16
?checkShipCollisions@enemy@gam@@QAE_NUSDL_Rect@@@Z PROC	; gam::enemy::checkShipCollisions, COMDAT
; _this$ = ecx

; 248  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 249  : 	// Go through each enemy
; 250  : 	for (size_t i = 0; i < enemies.size(); i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@checkShipC
$LN3@checkShipC:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@checkShipC:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QBEIXZ ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::size
	cmp	DWORD PTR _i$1[ebp], eax
	jae	SHORT $LN2@checkShipC

; 251  : 	{
; 252  : 		// Check with the bullet that has been passed through
; 253  : 		if (SDL_HasIntersection(&enemies[i], &ship))

	lea	eax, DWORD PTR _ship$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAEAAUSDL_Rect@@I@Z ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::operator[]
	push	eax
	call	_SDL_HasIntersection
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1@checkShipC

; 254  : 		{
; 255  : 			// If hit, Teleport enemy off screen
; 256  : 			return true;

	mov	al, 1
	jmp	SHORT $LN5@checkShipC
$LN1@checkShipC:

; 257  : 		}
; 258  : 	}

	jmp	SHORT $LN3@checkShipC
$LN2@checkShipC:

; 259  : 	return false;

	xor	al, al
$LN5@checkShipC:

; 260  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?checkShipCollisions@enemy@gam@@QAE_NUSDL_Rect@@@Z ENDP	; gam::enemy::checkShipCollisions
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File f:\finished_projects\project_files\whitenoise\james robertson sdl final\sdl_game\sdl_game\enemy.cpp
;	COMDAT ?restartGame@enemy@gam@@QAEXXZ
_TEXT	SEGMENT
_i$1 = -20						; size = 4
_this$ = -8						; size = 4
?restartGame@enemy@gam@@QAEXXZ PROC			; gam::enemy::restartGame, COMDAT
; _this$ = ecx

; 241  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 242  : 	for (size_t i = 0; i < enemies.size(); i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN3@restartGam
$LN2@restartGam:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN3@restartGam:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QBEIXZ ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::size
	cmp	DWORD PTR _i$1[ebp], eax
	jae	SHORT $LN4@restartGam

; 243  : 	{
; 244  : 		enemies[i].y = 4500;

	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAEAAUSDL_Rect@@I@Z ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::operator[]
	mov	DWORD PTR [eax+4], 4500			; 00001194H

; 245  : 	}

	jmp	SHORT $LN2@restartGam
$LN4@restartGam:

; 246  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?restartGame@enemy@gam@@QAEXXZ ENDP			; gam::enemy::restartGame
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File f:\finished_projects\project_files\whitenoise\james robertson sdl final\sdl_game\sdl_game\enemy.cpp
;	COMDAT ?checkCollisions@enemy@gam@@QAE_NUSDL_Rect@@@Z
_TEXT	SEGMENT
_i$1 = -20						; size = 4
_this$ = -8						; size = 4
_bullet$ = 8						; size = 16
?checkCollisions@enemy@gam@@QAE_NUSDL_Rect@@@Z PROC	; gam::enemy::checkCollisions, COMDAT
; _this$ = ecx

; 225  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 226  : 	// Go through each enemy
; 227  : 	for (size_t i = 0; i < enemies.size(); i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@checkColli
$LN3@checkColli:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@checkColli:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QBEIXZ ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::size
	cmp	DWORD PTR _i$1[ebp], eax
	jae	SHORT $LN2@checkColli

; 228  : 	{
; 229  : 		// Check with the bullet that has been passed through
; 230  : 		if (SDL_HasIntersection(&enemies[i], &bullet))

	lea	eax, DWORD PTR _bullet$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAEAAUSDL_Rect@@I@Z ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::operator[]
	push	eax
	call	_SDL_HasIntersection
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1@checkColli

; 231  : 		{
; 232  : 			// If hit, Teleport enemy off screen
; 233  : 			enemies[i].x = 4000;

	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAEAAUSDL_Rect@@I@Z ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::operator[]
	mov	DWORD PTR [eax], 4000			; 00000fa0H

; 234  : 			return true;

	mov	al, 1
	jmp	SHORT $LN5@checkColli
$LN1@checkColli:

; 235  : 		}
; 236  : 	}

	jmp	SHORT $LN3@checkColli
$LN2@checkColli:

; 237  : 	return false;

	xor	al, al
$LN5@checkColli:

; 238  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?checkCollisions@enemy@gam@@QAE_NUSDL_Rect@@@Z ENDP	; gam::enemy::checkCollisions
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File f:\finished_projects\project_files\whitenoise\james robertson sdl final\sdl_game\sdl_game\enemy.cpp
;	COMDAT ?drawEnemy@enemy@gam@@QAEXPAUSDL_Renderer@@PAUSDL_Texture@@@Z
_TEXT	SEGMENT
_i$1 = -20						; size = 4
_this$ = -8						; size = 4
_Renderer$ = 8						; size = 4
_Bullet$ = 12						; size = 4
?drawEnemy@enemy@gam@@QAEXPAUSDL_Renderer@@PAUSDL_Texture@@@Z PROC ; gam::enemy::drawEnemy, COMDAT
; _this$ = ecx

; 211  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 212  : 	// Loop through the vector of the enemies
; 213  : 	for (size_t i = 0; i < enemies.size(); i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN3@drawEnemy
$LN2@drawEnemy:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN3@drawEnemy:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QBEIXZ ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::size
	cmp	DWORD PTR _i$1[ebp], eax
	jae	SHORT $LN4@drawEnemy

; 214  : 	{
; 215  : 		// Draw onto the screen
; 216  : 		SDL_QueryTexture(Bullet, NULL, NULL, &enemies[i].w, &enemies[i].h);

	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAEAAUSDL_Rect@@I@Z ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::operator[]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _i$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAEAAUSDL_Rect@@I@Z ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::operator[]
	add	eax, 8
	push	eax
	push	0
	push	0
	mov	edx, DWORD PTR _Bullet$[ebp]
	push	edx
	call	_SDL_QueryTexture
	add	esp, 20					; 00000014H

; 217  : 		SDL_RenderCopy(Renderer, Bullet, NULL, &enemies[i]);

	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAEAAUSDL_Rect@@I@Z ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::operator[]
	push	eax
	push	0
	mov	ecx, DWORD PTR _Bullet$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Renderer$[ebp]
	push	edx
	call	_SDL_RenderCopy
	add	esp, 16					; 00000010H

; 218  : 	}

	jmp	SHORT $LN2@drawEnemy
$LN4@drawEnemy:

; 219  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?drawEnemy@enemy@gam@@QAEXPAUSDL_Renderer@@PAUSDL_Texture@@@Z ENDP ; gam::enemy::drawEnemy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File f:\finished_projects\project_files\whitenoise\james robertson sdl final\sdl_game\sdl_game\enemy.cpp
;	COMDAT ?moveEnemyPatterns@enemy@gam@@QAEXXZ
_TEXT	SEGMENT
tv192 = -256						; size = 4
tv171 = -256						; size = 4
tv162 = -256						; size = 4
tv141 = -256						; size = 4
tv132 = -256						; size = 4
tv79 = -256						; size = 4
tv66 = -256						; size = 4
_i$1 = -56						; size = 4
_i$2 = -44						; size = 4
_i$3 = -32						; size = 4
_i$4 = -20						; size = 4
_this$ = -8						; size = 4
?moveEnemyPatterns@enemy@gam@@QAEXXZ PROC		; gam::enemy::moveEnemyPatterns, COMDAT
; _this$ = ecx

; 148  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 64					; 00000040H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 149  : 	switch (patternID)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+21]
	mov	DWORD PTR tv66[ebp], ecx
	cmp	DWORD PTR tv66[ebp], 3
	ja	$LN23@moveEnemyP
	mov	edx, DWORD PTR tv66[ebp]
	jmp	DWORD PTR $LN25@moveEnemyP[edx*4]
$LN20@moveEnemyP:

; 150  : 	{
; 151  : 	case 0:
; 152  : 		for (size_t i = 0; i < enemies.size(); i++)

	mov	DWORD PTR _i$4[ebp], 0
	jmp	SHORT $LN19@moveEnemyP
$LN18@moveEnemyP:
	mov	eax, DWORD PTR _i$4[ebp]
	add	eax, 1
	mov	DWORD PTR _i$4[ebp], eax
$LN19@moveEnemyP:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QBEIXZ ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::size
	cmp	DWORD PTR _i$4[ebp], eax
	jae	SHORT $LN17@moveEnemyP

; 153  : 		{
; 154  : 			// Move the enemy "South - East"
; 155  : 			enemies[i].y += velocity;

	mov	eax, DWORD PTR _i$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAEAAUSDL_Rect@@I@Z ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::operator[]
	add	eax, 4
	mov	DWORD PTR tv79[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+16]
	mov	eax, DWORD PTR tv79[ebp]
	add	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv79[ebp]
	mov	DWORD PTR [ecx], edx

; 156  : 
; 157  : 			if (enemies[i].y > 4000)

	mov	eax, DWORD PTR _i$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAEAAUSDL_Rect@@I@Z ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::operator[]
	cmp	DWORD PTR [eax+4], 4000			; 00000fa0H
	jle	SHORT $LN16@moveEnemyP

; 158  : 			{
; 159  : 				eraseEnemy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?eraseEnemy@enemy@gam@@QAEXXZ		; gam::enemy::eraseEnemy
$LN16@moveEnemyP:

; 160  : 			}
; 161  : 		}

	jmp	SHORT $LN18@moveEnemyP
$LN17@moveEnemyP:

; 162  : 		break;

	jmp	$LN23@moveEnemyP
$LN15@moveEnemyP:

; 163  : 	case 1:
; 164  : 		// For loop to move each enemy
; 165  : 		for (size_t i = 0; i < enemies.size(); i++)

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN14@moveEnemyP
$LN13@moveEnemyP:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN14@moveEnemyP:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QBEIXZ ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::size
	cmp	DWORD PTR _i$3[ebp], eax
	jae	SHORT $LN12@moveEnemyP

; 166  : 		{
; 167  : 			// Move the enemy "South - East"
; 168  : 			enemies[i].y += velocity;

	mov	eax, DWORD PTR _i$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAEAAUSDL_Rect@@I@Z ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::operator[]
	add	eax, 4
	mov	DWORD PTR tv132[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+16]
	mov	eax, DWORD PTR tv132[ebp]
	add	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv132[ebp]
	mov	DWORD PTR [ecx], edx

; 169  : 			enemies[i].x += velocity;

	mov	eax, DWORD PTR _i$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAEAAUSDL_Rect@@I@Z ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::operator[]
	mov	DWORD PTR tv141[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+16]
	mov	eax, DWORD PTR tv141[ebp]
	add	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv141[ebp]
	mov	DWORD PTR [ecx], edx

; 170  : 
; 171  : 			// If they're off screen delete them!
; 172  : 			if (enemies[i].y > 4000)

	mov	eax, DWORD PTR _i$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAEAAUSDL_Rect@@I@Z ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::operator[]
	cmp	DWORD PTR [eax+4], 4000			; 00000fa0H
	jle	SHORT $LN11@moveEnemyP

; 173  : 			{
; 174  : 				eraseEnemy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?eraseEnemy@enemy@gam@@QAEXXZ		; gam::enemy::eraseEnemy
$LN11@moveEnemyP:

; 175  : 			}
; 176  : 		}

	jmp	$LN13@moveEnemyP
$LN12@moveEnemyP:

; 177  : 		break;

	jmp	$LN23@moveEnemyP
$LN10@moveEnemyP:

; 178  : 
; 179  : 	case 2:
; 180  : 		for (size_t i = 0; i < enemies.size(); i++)

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN9@moveEnemyP
$LN8@moveEnemyP:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN9@moveEnemyP:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QBEIXZ ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::size
	cmp	DWORD PTR _i$2[ebp], eax
	jae	SHORT $LN7@moveEnemyP

; 181  : 		{
; 182  : 			// Move the enemy "South - East"
; 183  : 			enemies[i].y += velocity;

	mov	eax, DWORD PTR _i$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAEAAUSDL_Rect@@I@Z ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::operator[]
	add	eax, 4
	mov	DWORD PTR tv162[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+16]
	mov	eax, DWORD PTR tv162[ebp]
	add	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv162[ebp]
	mov	DWORD PTR [ecx], edx

; 184  : 			enemies[i].x -= velocity;

	mov	eax, DWORD PTR _i$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAEAAUSDL_Rect@@I@Z ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::operator[]
	mov	DWORD PTR tv171[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+16]
	mov	eax, DWORD PTR tv171[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, edx
	mov	edx, DWORD PTR tv171[ebp]
	mov	DWORD PTR [edx], ecx

; 185  : 
; 186  : 			if (enemies[i].y > 4000)

	mov	eax, DWORD PTR _i$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAEAAUSDL_Rect@@I@Z ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::operator[]
	cmp	DWORD PTR [eax+4], 4000			; 00000fa0H
	jle	SHORT $LN6@moveEnemyP

; 187  : 			{
; 188  : 				eraseEnemy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?eraseEnemy@enemy@gam@@QAEXXZ		; gam::enemy::eraseEnemy
$LN6@moveEnemyP:

; 189  : 			}
; 190  : 		}

	jmp	$LN8@moveEnemyP
$LN7@moveEnemyP:

; 191  : 		break;

	jmp	SHORT $LN23@moveEnemyP
$LN5@moveEnemyP:

; 192  : 	case 3:
; 193  : 		for (size_t i = 0; i < enemies.size(); i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@moveEnemyP
$LN3@moveEnemyP:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@moveEnemyP:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QBEIXZ ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::size
	cmp	DWORD PTR _i$1[ebp], eax
	jae	SHORT $LN23@moveEnemyP

; 194  : 		{
; 195  : 			// Move the enemy "South - East"
; 196  : 			enemies[i].y += velocity;

	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAEAAUSDL_Rect@@I@Z ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::operator[]
	add	eax, 4
	mov	DWORD PTR tv192[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+16]
	mov	eax, DWORD PTR tv192[ebp]
	add	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv192[ebp]
	mov	DWORD PTR [ecx], edx

; 197  : 
; 198  : 			if (enemies[i].y > 4000)

	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAEAAUSDL_Rect@@I@Z ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::operator[]
	cmp	DWORD PTR [eax+4], 4000			; 00000fa0H
	jle	SHORT $LN1@moveEnemyP

; 199  : 			{
; 200  : 				eraseEnemy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?eraseEnemy@enemy@gam@@QAEXXZ		; gam::enemy::eraseEnemy
$LN1@moveEnemyP:

; 201  : 			}
; 202  : 		}

	jmp	SHORT $LN3@moveEnemyP
$LN23@moveEnemyP:

; 203  : 		break;
; 204  : 	}
; 205  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@moveEnemyP:
	DD	$LN20@moveEnemyP
	DD	$LN15@moveEnemyP
	DD	$LN10@moveEnemyP
	DD	$LN5@moveEnemyP
?moveEnemyPatterns@enemy@gam@@QAEXXZ ENDP		; gam::enemy::moveEnemyPatterns
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File f:\finished_projects\project_files\whitenoise\james robertson sdl final\sdl_game\sdl_game\enemy.cpp
;	COMDAT ?spawnEnemy@enemy@gam@@QAEXHH@Z
_TEXT	SEGMENT
_temp$ = -36						; size = 16
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?spawnEnemy@enemy@gam@@QAEXHH@Z PROC			; gam::enemy::spawnEnemy, COMDAT
; _this$ = ecx

; 128  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 	// Temp Rect to push to the vector
; 130  : 	SDL_Rect temp;
; 131  : 
; 132  : 	// Assign the values to the ones that were passed through
; 133  : 	temp.x = x;

	mov	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR _temp$[ebp], eax

; 134  : 	temp.y = y;

	mov	eax, DWORD PTR _y$[ebp]
	mov	DWORD PTR _temp$[ebp+4], eax

; 135  : 
; 136  : 	// Push it to the vector
; 137  : 	enemies.push_back(temp);

	lea	eax, DWORD PTR _temp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push_back@?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAEXABUSDL_Rect@@@Z ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::push_back

; 138  : 
; 139  : 	///int random = rand() % 800;
; 140  : 	/// Place different patterns here that spawn - Type
; 141  : 	/// Case statement here with random basing the outcome every 15 seconds (?) - That will be passed through - or called through main
; 142  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@spawnEnemy
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN5@spawnEnemy:
	DD	1
	DD	$LN4@spawnEnemy
$LN4@spawnEnemy:
	DD	-36					; ffffffdcH
	DD	16					; 00000010H
	DD	$LN3@spawnEnemy
$LN3@spawnEnemy:
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
?spawnEnemy@enemy@gam@@QAEXHH@Z ENDP			; gam::enemy::spawnEnemy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File f:\finished_projects\project_files\whitenoise\james robertson sdl final\sdl_game\sdl_game\enemy.cpp
;	COMDAT ?spawnPattern@enemy@gam@@QAEXXZ
_TEXT	SEGMENT
tv70 = -256						; size = 4
_i$1 = -56						; size = 4
_i$2 = -44						; size = 4
_i$3 = -32						; size = 4
_i$4 = -20						; size = 4
_this$ = -8						; size = 4
?spawnPattern@enemy@gam@@QAEXXZ PROC			; gam::enemy::spawnPattern, COMDAT
; _this$ = ecx

; 83   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 64					; 00000040H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 84   : 	randomPattern = rand() % 4;

	mov	esi, esp
	call	DWORD PTR __imp__rand
	cmp	esi, esp
	call	__RTC_CheckEsp
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN21@spawnPatte
	dec	eax
	or	eax, -4					; fffffffcH
	inc	eax
$LN21@spawnPatte:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+20], al

; 85   : 
; 86   : 	switch (randomPattern)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+20]
	mov	DWORD PTR tv70[ebp], ecx
	cmp	DWORD PTR tv70[ebp], 3
	ja	$LN19@spawnPatte
	mov	edx, DWORD PTR tv70[ebp]
	jmp	DWORD PTR $LN22@spawnPatte[edx*4]
$LN16@spawnPatte:

; 87   : 	{
; 88   : 	case 0:
; 89   : 		for (size_t i = 0; i < 8; i++)

	mov	DWORD PTR _i$4[ebp], 0
	jmp	SHORT $LN15@spawnPatte
$LN14@spawnPatte:
	mov	eax, DWORD PTR _i$4[ebp]
	add	eax, 1
	mov	DWORD PTR _i$4[ebp], eax
$LN15@spawnPatte:
	cmp	DWORD PTR _i$4[ebp], 8
	jae	SHORT $LN13@spawnPatte

; 90   : 		{
; 91   : 			spawnEnemy(One[i].x, One[i].y);

	mov	eax, DWORD PTR _i$4[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+eax*4+24]
	push	edx
	mov	eax, DWORD PTR _i$4[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+eax*4+22]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?spawnEnemy@enemy@gam@@QAEXHH@Z		; gam::enemy::spawnEnemy

; 92   : 			patternID = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+21], 0

; 93   : 		}

	jmp	SHORT $LN14@spawnPatte
$LN13@spawnPatte:

; 94   : 		break;

	jmp	$LN19@spawnPatte
$LN12@spawnPatte:

; 95   : 	case 1:
; 96   : 		for (size_t i = 0; i < 8; i++)

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN11@spawnPatte
$LN10@spawnPatte:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN11@spawnPatte:
	cmp	DWORD PTR _i$3[ebp], 8
	jae	SHORT $LN9@spawnPatte

; 97   : 		{
; 98   : 			spawnEnemy(Two[i].x, Two[i].y);

	mov	eax, DWORD PTR _i$3[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+eax*4+56]
	push	edx
	mov	eax, DWORD PTR _i$3[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+eax*4+54]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?spawnEnemy@enemy@gam@@QAEXHH@Z		; gam::enemy::spawnEnemy

; 99   : 			patternID = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+21], 1

; 100  : 		}

	jmp	SHORT $LN10@spawnPatte
$LN9@spawnPatte:

; 101  : 		break;

	jmp	$LN19@spawnPatte
$LN8@spawnPatte:

; 102  : 	case 2:
; 103  : 		for (size_t i = 0; i < 8; i++)

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN7@spawnPatte
$LN6@spawnPatte:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN7@spawnPatte:
	cmp	DWORD PTR _i$2[ebp], 8
	jae	SHORT $LN5@spawnPatte

; 104  : 		{
; 105  : 			spawnEnemy(Three[i].x, Three[i].y);

	mov	eax, DWORD PTR _i$2[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+eax*4+88]
	push	edx
	mov	eax, DWORD PTR _i$2[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+eax*4+86]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?spawnEnemy@enemy@gam@@QAEXHH@Z		; gam::enemy::spawnEnemy

; 106  : 			patternID = 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+21], 2

; 107  : 		}

	jmp	SHORT $LN6@spawnPatte
$LN5@spawnPatte:

; 108  : 		break;

	jmp	SHORT $LN19@spawnPatte
$LN4@spawnPatte:

; 109  : 	case 3:
; 110  : 		for (size_t i = 0; i < 8; i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN3@spawnPatte
$LN2@spawnPatte:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN3@spawnPatte:
	cmp	DWORD PTR _i$1[ebp], 8
	jae	SHORT $LN19@spawnPatte

; 111  : 		{
; 112  : 			spawnEnemy(Four[i].x, Four[i].y);

	mov	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+eax*4+120]
	push	edx
	mov	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+eax*4+118]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?spawnEnemy@enemy@gam@@QAEXHH@Z		; gam::enemy::spawnEnemy

; 113  : 			patternID = 3;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+21], 3

; 114  : 		}

	jmp	SHORT $LN2@spawnPatte
$LN19@spawnPatte:

; 115  : 		break;
; 116  : 	}
; 117  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN22@spawnPatte:
	DD	$LN16@spawnPatte
	DD	$LN12@spawnPatte
	DD	$LN8@spawnPatte
	DD	$LN4@spawnPatte
?spawnPattern@enemy@gam@@QAEXXZ ENDP			; gam::enemy::spawnPattern
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File f:\finished_projects\project_files\whitenoise\james robertson sdl final\sdl_game\sdl_game\enemy.cpp
;	COMDAT ??0enemy@gam@@QAE@XZ
_TEXT	SEGMENT
_i$1 = -32						; size = 4
_i$2 = -20						; size = 4
_this$ = -8						; size = 4
??0enemy@gam@@QAE@XZ PROC				; gam::enemy::enemy, COMDAT
; _this$ = ecx

; 17   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$vector@USDL_Rect@@V?$allocator@USDL_Rect@@@std@@@std@@QAE@XZ ; std::vector<SDL_Rect,std::allocator<SDL_Rect> >::vector<SDL_Rect,std::allocator<SDL_Rect> >

; 18   : 	velocity = 14;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+16], 14			; 0000000eH

; 19   : 	patternID = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+21], 0

; 20   : 	positionIncrement = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+18], ax

; 21   : 
; 22   : 	// Initilise all of the pre set patterns to the level
; 23   : 	One[0].x = 700;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 700				; 000002bcH
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+ecx+22], dx

; 24   : 	One[0].y = -700;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, -700				; fffffd44H
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+ecx+24], dx

; 25   : 	One[1].x = 550;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 550				; 00000226H
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+eax+22], cx

; 26   : 	One[1].y = -850;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, -850				; fffffcaeH
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+eax+24], cx

; 27   : 
; 28   : 	One[2].x = 700;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 700				; 000002bcH
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+eax+22], cx

; 29   : 	One[2].y = -850;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, -850				; fffffcaeH
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+eax+24], cx

; 30   : 	One[3].x = 850;

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, 850				; 00000352H
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+ecx+22], dx

; 31   : 	One[3].y = -850;

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, -850				; fffffcaeH
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+ecx+24], dx

; 32   : 
; 33   : 	One[4].x = 450;

	mov	eax, 4
	shl	eax, 2
	mov	ecx, 450				; 000001c2H
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+eax+22], cx

; 34   : 	One[4].y = -1000;

	mov	eax, 4
	shl	eax, 2
	mov	ecx, -1000				; fffffc18H
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+eax+24], cx

; 35   : 	One[5].x = 625;

	mov	eax, 4
	imul	ecx, eax, 5
	mov	edx, 625				; 00000271H
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+ecx+22], dx

; 36   : 	One[5].y = -1000;

	mov	eax, 4
	imul	ecx, eax, 5
	mov	edx, -1000				; fffffc18H
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+ecx+24], dx

; 37   : 
; 38   : 	One[6].x = 775;

	mov	eax, 4
	imul	ecx, eax, 6
	mov	edx, 775				; 00000307H
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+ecx+22], dx

; 39   : 	One[6].y = -1000;

	mov	eax, 4
	imul	ecx, eax, 6
	mov	edx, -1000				; fffffc18H
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+ecx+24], dx

; 40   : 	One[7].x = 925;

	mov	eax, 4
	imul	ecx, eax, 7
	mov	edx, 925				; 0000039dH
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+ecx+22], dx

; 41   : 	One[7].y = -1000;

	mov	eax, 4
	imul	ecx, eax, 7
	mov	edx, -1000				; fffffc18H
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+ecx+24], dx

; 42   : 
; 43   : 	for (size_t i = 0; i < 8; i++)

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN6@enemy
$LN5@enemy:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN6@enemy:
	cmp	DWORD PTR _i$2[ebp], 8
	jae	SHORT $LN4@enemy

; 44   : 	{
; 45   : 		Two[i].x = 300 - positionIncrement;

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+18]
	mov	edx, 300				; 0000012cH
	sub	edx, ecx
	mov	eax, DWORD PTR _i$2[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+eax*4+54], dx

; 46   : 		Two[i].y = -100 - positionIncrement;

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+18]
	mov	edx, -100				; ffffff9cH
	sub	edx, ecx
	mov	eax, DWORD PTR _i$2[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+eax*4+56], dx

; 47   : 		positionIncrement += 130;

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+18]
	add	ecx, 130				; 00000082H
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+18], cx

; 48   : 	}

	jmp	SHORT $LN5@enemy
$LN4@enemy:

; 49   : 
; 50   : 	positionIncrement = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+18], ax

; 51   : 
; 52   : 	for (size_t i = 0; i < 8; i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN3@enemy
$LN2@enemy:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN3@enemy:
	cmp	DWORD PTR _i$1[ebp], 8
	jae	SHORT $LN1@enemy

; 53   : 	{
; 54   : 		Three[i].x = 1500 + positionIncrement;

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+18]
	add	ecx, 1500				; 000005dcH
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+edx*4+86], cx

; 55   : 		Three[i].y = -200 + positionIncrement;

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+18]
	sub	ecx, 200				; 000000c8H
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+edx*4+88], cx

; 56   : 		positionIncrement += 130;

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+18]
	add	ecx, 130				; 00000082H
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+18], cx

; 57   : 	}

	jmp	SHORT $LN2@enemy
$LN1@enemy:

; 58   : 
; 59   : 	Four[0].x = 910;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 910				; 0000038eH
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+ecx+118], dx

; 60   : 	Four[0].y = -100;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, -100				; ffffff9cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+ecx+120], dx

; 61   : 
; 62   : 	Four[1].x = 780;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, 780				; 0000030cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+eax+118], cx

; 63   : 	Four[1].y = -230;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, -230				; ffffff1aH
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+eax+120], cx

; 64   : 
; 65   : 	Four[2].x = 650;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, 650				; 0000028aH
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+eax+118], cx

; 66   : 	Four[2].y = -360;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, -360				; fffffe98H
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+eax+120], cx

; 67   : 
; 68   : 	Four[3].x = 520;

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, 520				; 00000208H
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+ecx+118], dx

; 69   : 	Four[3].y = -490;

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, -490				; fffffe16H
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+ecx+120], dx

; 70   : 
; 71   : 	Four[4].x = 1040;

	mov	eax, 4
	shl	eax, 2
	mov	ecx, 1040				; 00000410H
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+eax+118], cx

; 72   : 	Four[4].y = -230;

	mov	eax, 4
	shl	eax, 2
	mov	ecx, -230				; ffffff1aH
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+eax+120], cx

; 73   : 
; 74   : 	Four[5].x = 1170;

	mov	eax, 4
	imul	ecx, eax, 5
	mov	edx, 1170				; 00000492H
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+ecx+118], dx

; 75   : 	Four[5].y = -360;

	mov	eax, 4
	imul	ecx, eax, 5
	mov	edx, -360				; fffffe98H
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+ecx+120], dx

; 76   : 
; 77   : 	Four[6].x = 1300;

	mov	eax, 4
	imul	ecx, eax, 6
	mov	edx, 1300				; 00000514H
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+ecx+118], dx

; 78   : 	Four[6].y = -490;

	mov	eax, 4
	imul	ecx, eax, 6
	mov	edx, -490				; fffffe16H
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+ecx+120], dx

; 79   : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0enemy@gam@@QAE@XZ ENDP				; gam::enemy::enemy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$di	SEGMENT
$T1 = -197						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3451 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ?_Orphan_me@_Iterator_base12@std@@QAEXXZ
_TEXT	SEGMENT
__Pnext$1 = -20						; size = 4
_this$ = -8						; size = 4
?_Orphan_me@_Iterator_base12@std@@QAEXXZ PROC		; std::_Iterator_base12::_Orphan_me, COMDAT
; _this$ = ecx

; 192  : 		{	// cut ties with parent

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 193  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 194  : 		if (_Myproxy != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@Orphan_me

; 195  : 			{	// adopted, remove self from list
; 196  : 			_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR __Pnext$1[ebp], ecx
$LN3@Orphan_me:

; 197  : 			while (*_Pnext != 0 && *_Pnext != this)

	mov	eax, DWORD PTR __Pnext$1[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Orphan_me
	mov	eax, DWORD PTR __Pnext$1[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _this$[ebp]
	je	SHORT $LN2@Orphan_me

; 198  : 				_Pnext = &(*_Pnext)->_Mynextiter;

	mov	eax, DWORD PTR __Pnext$1[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR __Pnext$1[ebp], ecx
	jmp	SHORT $LN3@Orphan_me
$LN2@Orphan_me:

; 199  : 
; 200  : 			if (*_Pnext == 0)

	mov	eax, DWORD PTR __Pnext$1[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN1@Orphan_me

; 201  : 				_DEBUG_ERROR("ITERATOR LIST CORRUPTED!");

	mov	esi, esp
	push	201					; 000000c9H
	push	OFFSET ??_C@_1JA@EKKHPHED@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@Orphan_me:

; 202  : 			*_Pnext = _Mynextiter;

	mov	eax, DWORD PTR __Pnext$1[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 203  : 			_Myproxy = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$LN5@Orphan_me:

; 204  : 			}
; 205  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 206  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Orphan_me@_Iterator_base12@std@@QAEXXZ ENDP		; std::_Iterator_base12::_Orphan_me
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ PROC	; std::_Iterator_base12::_Getpnext, COMDAT
; _this$ = ecx

; 187  : 		{	// get address of remaining iterator chain

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 188  : 		return (&_Mynextiter);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4

; 189  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ENDP	; std::_Iterator_base12::_Getpnext
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ
_TEXT	SEGMENT
tv68 = -208						; size = 4
_this$ = -8						; size = 4
?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ PROC ; std::_Iterator_base12::_Getcont, COMDAT
; _this$ = ecx

; 182  : 		{	// get owning container

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN3@Getcont
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@Getcont
$LN3@Getcont:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv68[ebp], eax
$LN4@Getcont:
	mov	eax, DWORD PTR tv68[ebp]

; 184  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ENDP ; std::_Iterator_base12::_Getcont
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ?_Clrcont@_Iterator_base12@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Clrcont@_Iterator_base12@std@@QAEXXZ PROC		; std::_Iterator_base12::_Clrcont, COMDAT
; _this$ = ecx

; 177  : 		{	// disown owning container

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 178  : 		_Myproxy = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 179  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Clrcont@_Iterator_base12@std@@QAEXXZ ENDP		; std::_Iterator_base12::_Clrcont
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
_TEXT	SEGMENT
__Lock$2 = -56						; size = 4
__Parent_proxy$3 = -44					; size = 4
__Lock$4 = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Parent$ = 8						; size = 4
?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z PROC ; std::_Iterator_base12::_Adopt, COMDAT
; _this$ = ecx

; 148  : 		{	// adopt this iterator by parent

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 149  : 		if (_Parent == 0)

	cmp	DWORD PTR __Parent$[ebp], 0
	jne	SHORT $LN3@Adopt

; 150  : 			{	// no future parent, just disown current parent
; 151  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 152  : 			_Lockit _Lock(_LOCK_DEBUG);

	mov	esi, esp
	push	3
	lea	ecx, DWORD PTR __Lock$4[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 153  : 			_Orphan_me();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 154  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 155  : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$4[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 156  : 		else

	jmp	SHORT $LN4@Adopt
$LN3@Adopt:

; 157  : 			{	// have a parent, do adoption
; 158  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;

	mov	eax, DWORD PTR __Parent$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Parent_proxy$3[ebp], ecx

; 159  : 
; 160  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 161  : 			if (_Myproxy != _Parent_proxy)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR __Parent_proxy$3[ebp]
	je	SHORT $LN4@Adopt

; 162  : 				{	// change parentage
; 163  : 				_Lockit _Lock(_LOCK_DEBUG);

	mov	esi, esp
	push	3
	lea	ecx, DWORD PTR __Lock$2[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 164  : 				_Orphan_me();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 165  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Parent_proxy$3[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 166  : 				_Parent_proxy->_Myfirstiter = this;

	mov	eax, DWORD PTR __Parent_proxy$3[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 167  : 				_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Parent_proxy$3[ebp]
	mov	DWORD PTR [eax], ecx

; 168  : 				}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$2[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@Adopt:

; 169  : 
; 170  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 171  : 			_Myproxy = _Parent_proxy;
; 172  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 173  : 			}
; 174  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN12@Adopt
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN12@Adopt:
	DD	2
	DD	$LN11@Adopt
$LN11@Adopt:
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN8@Adopt
	DD	-56					; ffffffc8H
	DD	4
	DD	$LN9@Adopt
$LN9@Adopt:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
$LN8@Adopt:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0:
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$4[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	jmp	__RTC_CheckEsp
__unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1:
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$2[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	jmp	__RTC_CheckEsp
__ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-256]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ENDP ; std::_Iterator_base12::_Adopt
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??1_Iterator_base12@std@@QAE@XZ
_TEXT	SEGMENT
__Lock$ = -20						; size = 4
_this$ = -8						; size = 4
??1_Iterator_base12@std@@QAE@XZ PROC			; std::_Iterator_base12::~_Iterator_base12, COMDAT
; _this$ = ecx

; 140  : 		{	// destroy the iterator

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 141  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 142  : 		_Lockit _Lock(_LOCK_DEBUG);

	mov	esi, esp
	push	3
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 143  : 		_Orphan_me();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 144  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 145  : 		}

	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Iterator_b
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN5@Iterator_b:
	DD	1
	DD	$LN4@Iterator_b
$LN4@Iterator_b:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN3@Iterator_b
$LN3@Iterator_b:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
??1_Iterator_base12@std@@QAE@XZ ENDP			; std::_Iterator_base12::~_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
_TEXT	SEGMENT
__Lock$2 = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z PROC		; std::_Iterator_base12::operator=, COMDAT
; _this$ = ecx

; 124  : 		{	// assign an iterator

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN4@operator
	jmp	SHORT $LN3@operator
$LN4@operator:

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)

	mov	eax, DWORD PTR __Right$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@operator

; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 129  : 		else

	jmp	SHORT $LN3@operator
$LN2@operator:

; 130  : 			{	// becoming invalid, disown current parent
; 131  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 132  : 			_Lockit _Lock(_LOCK_DEBUG);

	mov	esi, esp
	push	3
	lea	ecx, DWORD PTR __Lock$2[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 133  : 			_Orphan_me();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 134  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 135  : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$2[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@operator:

; 136  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 137  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN11@operator
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN11@operator:
	DD	1
	DD	$LN10@operator
$LN10@operator:
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN8@operator
$LN8@operator:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0:
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$2[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	jmp	__RTC_CheckEsp
__ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ENDP		; std::_Iterator_base12::operator=
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??0_Iterator_base12@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??0_Iterator_base12@std@@QAE@ABU01@@Z PROC		; std::_Iterator_base12::_Iterator_base12, COMDAT
; _this$ = ecx

; 119  : 		{	// copy an iterator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 120  : 		*this = _Right;

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ; std::_Iterator_base12::operator=

; 121  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0_Iterator_base12@std@@QAE@ABU01@@Z ENDP		; std::_Iterator_base12::_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??0_Iterator_base12@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Iterator_base12@std@@QAE@XZ PROC			; std::_Iterator_base12::_Iterator_base12, COMDAT
; _this$ = ecx

; 114  : 		{	// construct orphaned iterator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 115  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iterator_base12@std@@QAE@XZ ENDP			; std::_Iterator_base12::_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??0_Container_proxy@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Container_proxy@std@@QAE@XZ PROC			; std::_Container_proxy::_Container_proxy, COMDAT
; _this$ = ecx

; 68   : 		{	// construct from pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 69   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Container_proxy@std@@QAE@XZ ENDP			; std::_Container_proxy::_Container_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$di	SEGMENT
$T1 = -197						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 70   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 65   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 61   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
;	COMDAT _hypot
_TEXT	SEGMENT
__X$ = 8						; size = 8
__Y$ = 16						; size = 8
_hypot	PROC						; COMDAT

; 556  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 557  :     return _hypot(_X, _Y);

	mov	esi, esp
	sub	esp, 8
	movsd	xmm0, QWORD PTR __Y$[ebp]
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR __X$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp___hypot
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 558  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_hypot	ENDP
_TEXT	ENDS
END
